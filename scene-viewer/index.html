# Dateien & Patches

> Diese Seite enth√§lt **alle notwendigen √Ñnderungen**:
>
> 1. **Neue Datei** `area-viewer/scene-viewer/index.html` (fertiger Viewer mit Welcome-Kachel, Animation & Audio)
> 2. **Patches** f√ºr `area-editor/index.html` (neuer Publish-Modus ‚ÄûScene Viewer‚Äú, Anim/Audio/Poster Upload, Link-Gen)

---

## 1) Neue Datei ‚Äî `/area-viewer/scene-viewer/index.html`

```html
<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARea ‚Äì Scene Viewer</title>
<style>
  :root{ --bg:#0e1116; --panel:#111828; --panel2:#192339; --text:#e9ecf5; --muted:#9fb3d9; --border:#24314a; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,Segoe UI,Inter,Roboto,Arial}
  #app{position:fixed;inset:0}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:fixed;inset:0;display:grid;place-items:center;padding:24px;background:linear-gradient(180deg, rgba(14,17,22,.9), rgba(14,17,22,.96))}
  .card{width:min(880px,92vw);border:1px solid var(--border);border-radius:20px;overflow:hidden;background:linear-gradient(180deg,#0b1220,#0e1422);box-shadow:0 12px 40px rgba(0,0,0,.4);display:grid;grid-template-columns:320px 1fr}
  .poster{background:#0a1220;min-height:260px}
  .poster img{width:100%;height:100%;object-fit:cover;display:block}
  .body{padding:22px}
  .eyebrow{font-size:12px;letter-spacing:.18em;text-transform:uppercase;color:var(--muted)}
  h1{font-size:28px;margin:.35rem 0 .4rem;line-height:1.2}
  p{color:#cbd5e1;margin:.2rem 0 .8rem}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:.6rem}
  .btn{cursor:pointer;border:1px solid var(--border);background:linear-gradient(180deg,#1a2337,#162033);color:var(--text);padding:10px 14px;border-radius:12px;font-weight:700}
  .hud{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;display:flex;gap:10px;background:rgba(14,17,22,.6);border:1px solid var(--border);border-radius:999px;padding:8px;backdrop-filter: blur(6px)}
  .hud button{all:unset;cursor:pointer;padding:8px 12px;border-radius:10px}
  .toast{position:fixed;top:12px;right:12px;background:#111828;border:1px solid #24314a;color:#dbe1f1;padding:8px 12px;border-radius:10px;font-size:13px;box-shadow:0 8px 24px rgba(0,0,0,.25)}
  @media (max-width:860px){ .card{grid-template-columns:1fr} .poster{max-height:40vh} }
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app"></div>

<div id="welcome" class="overlay" hidden>
  <div class="card">
    <div class="poster"><img id="welcomePoster" alt="Poster"></div>
    <div class="body">
      <div class="eyebrow" id="welcomeEyebrow">ARea ‚Äì Scene Viewer</div>
      <h1 id="welcomeTitle">Willkommen</h1>
      <p id="welcomeDesc">Diese Szene enth√§lt Animation und ggf. Audio. Klicke auf OK, um zu starten.</p>
      <div class="row">
        <button id="welcomeStart" class="btn">OK</button>
        <span class="muted" id="welcomeHint" style="color:#9fb3d9;font-size:13px">Audio startet ggf. nach Klick (Autoplay-Policy)</span>
      </div>
    </div>
  </div>
</div>

<div id="hud" class="hud" hidden>
  <button id="btnPlay" title="Play/Pause">‚ñ∂Ô∏é/‚è∏</button>
  <button id="btnReplay" title="Neu starten">‚Üª</button>
  <button id="btnSound" title="Ton an/aus">üîä</button>
</div>

<div id="toasts" style="display:grid;gap:10px;position:fixed;top:12px;right:12px"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

const $ = s => document.querySelector(s);
const app = $('#app'); const toasts = $('#toasts');
function toast(m){ const d=document.createElement('div'); d.className='toast'; d.textContent=m; toasts.appendChild(d); setTimeout(()=>d.remove(),2600); }

const qs = new URLSearchParams(location.search);
const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/,'');
const sceneId = (qs.get('scene') || '').trim();
const src = (qs.get('src') || '').trim();

const configURL = src || (sceneId ? `${workerBase}/scenes/${encodeURIComponent(sceneId)}/scene.json` : '');
if (!configURL){ toast('Keine scene.json ‚Äì ?scene=ID oder ?src=URL verwenden.'); }

const DEFAULTS = {
  ui:{ showGround:true, autocenter:true, welcome:{ eyebrow:'ARea ‚Äì Szene', title:'Willkommen', desc:'Klicke auf OK, um zu starten.', cta:'OK', poster:'' } },
  camera:{ fov:50, near:.1, far:100, start:[2.5,1.6,3.6], lookAt:[0,1,0] },
  model:{ url:'', scale:1, rotateY:0 },
  animation:{ enabled:true, clipName:null, start:'onStart', loop:false, iterations:1, clampWhenFinished:true, crossfade:.25, timeScale:1 },
  audio:{ url:'', autoplay:'withAnimation', loop:true, volume:.85 },
  triggers:{ buttonLabel:'Animation abspielen', clickAnywhere:false }
};

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.setSize(innerWidth, innerHeight);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene(); scene.background = new THREE.Color('#0b1020');
const camera = new THREE.PerspectiveCamera(DEFAULTS.camera.fov, innerWidth/innerHeight, DEFAULTS.camera.near, DEFAULTS.camera.far);
camera.position.set(...DEFAULTS.camera.start);
const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping=true; controls.target.set(...DEFAULTS.camera.lookAt);

const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.9); scene.add(hemi);
const dir  = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(4,6,3); scene.add(dir);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({ color:0x0d1323, roughness:.9, metalness:0 }));
ground.rotation.x = -Math.PI/2; scene.add(ground);

const listener = new THREE.AudioListener(); camera.add(listener);
const audio = new THREE.Audio(listener); const audioLoader = new THREE.AudioLoader();

const clock = new THREE.Clock();
let mixer=null, clip=null, action=null, playing=false, playCount=0;

const welcome = $('#welcome'), poster = $('#welcomePoster'), wTitle = $('#welcomeTitle'), wDesc = $('#welcomeDesc'), wStart = $('#welcomeStart'), wEyebrow = $('#welcomeEyebrow');
const hud = $('#hud'), btnPlay = $('#btnPlay'), btnReplay = $('#btnReplay'), btnSound = $('#btnSound');

function deepMerge(a,b){ for(const k in b){ if(b[k] && typeof b[k]==='object' && !Array.isArray(b[k])) a[k]=deepMerge(a[k]||{},b[k]); else a[k]=b[k]; } return a; }

const cfg = await (async()=>{
  try{ const r = await fetch(configURL, { mode:'cors', cache:'no-cache' }); if(!r.ok) throw new Error(r.status+' '+r.statusText);
       const j = await r.json(); return deepMerge(structuredClone(DEFAULTS), j);
  }catch(e){ toast('Config konnte nicht geladen werden ‚Äì Defaults genutzt.'); return structuredClone(DEFAULTS); }
})();

if (cfg.ui?.welcome){
  wEyebrow.textContent = cfg.ui.welcome.eyebrow || DEFAULTS.ui.welcome.eyebrow;
  wTitle.textContent   = cfg.ui.welcome.title   || DEFAULTS.ui.welcome.title;
  wDesc.textContent    = cfg.ui.welcome.desc    || DEFAULTS.ui.welcome.desc;
  if (cfg.ui.welcome.poster){ poster.src = cfg.ui.welcome.poster; } else { document.querySelector('.poster').style.display='none'; }
  welcome.hidden = false;
}

if (cfg.camera){
  camera.fov = cfg.camera.fov ?? camera.fov; camera.updateProjectionMatrix();
  if (cfg.camera.start) camera.position.set(...cfg.camera.start);
  if (cfg.camera.lookAt) controls.target.set(...cfg.camera.lookAt);
}
ground.visible = !!cfg.ui?.showGround;

const loader = new GLTFLoader(); loader.crossOrigin='anonymous';
let gltf=null;
try {
  gltf = await loader.loadAsync(cfg.model.url);
} catch(e) { toast('GLB laden fehlgeschlagen'); console.warn(e); }
const root = gltf?.scene || new THREE.Group();
root.traverse(o=>{ if(o.isMesh){ if(o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace; }});
root.scale.setScalar(cfg.model.scale||1); root.rotation.y = cfg.model.rotateY||0; scene.add(root);

// Auto-Center auf Ground
if (cfg.ui?.autocenter && root){
  const box = new THREE.Box3().setFromObject(root);
  const size = new THREE.Vector3(); box.getSize(size); const center = new THREE.Vector3(); box.getCenter(center);
  root.position.x += -center.x; root.position.z += -center.z; root.position.y += -box.min.y;
  const radius = Math.max(size.x,size.y,size.z)*0.6; const idealZ = radius/Math.tan((camera.fov*Math.PI/180)/2);
  camera.position.set(idealZ*0.8, radius*0.8, idealZ*1.1); controls.target.set(0, size.y*0.5, 0);
}

// Animationen
if (gltf?.animations?.length && cfg.animation.enabled){
  mixer = new THREE.AnimationMixer(root);
  clip = cfg.animation.clipName ? THREE.AnimationClip.findByName(gltf.animations, cfg.animation.clipName) : gltf.animations[0];
  if (!clip) clip = gltf.animations[0];
  action = mixer.clipAction(clip);
  action.clampWhenFinished = !!cfg.animation.clampWhenFinished;
  action.timeScale = cfg.animation.timeScale ?? 1;
  if (cfg.animation.loop){ action.setLoop(THREE.LoopRepeat, Infinity); }
  else { action.setLoop(THREE.LoopOnce, 0); }

  mixer.addEventListener('finished', ()=>{
    if(cfg.animation.loop) return;
    if(cfg.animation.iterations && Number.isFinite(cfg.animation.iterations)){
      playCount++;
      if (playCount < cfg.animation.iterations){ action.reset(); action.play(); }
      else { playing=false; }
    }
  });
}

// Audio
let audioReady=false;
if (cfg.audio?.url){
  try{
    await new Promise((resolve,reject)=> audioLoader.load(cfg.audio.url, (buf)=>{ audio.setBuffer(buf); audio.setLoop(!!cfg.audio.loop); audio.setVolume(cfg.audio.volume??.85); audioReady=true; resolve(); }, undefined, reject));
  }catch(e){ console.warn('Audio load fail', e); }
}

// Start- & HUD-Events
function playAnim(reset=false){ if(!action) return; if(reset){ action.reset(); playCount=0; } action.enabled=true; action.fadeIn(cfg.animation.crossfade||0).play(); playing=true; if(cfg.audio?.autoplay==='withAnimation'&&audioReady&&!audio.isPlaying) audio.play(); }
function pauseAnim(){ if(!action) return; action.paused = true; playing=false; }
function playSound(){ if(!audioReady) return; if(!audio.isPlaying){ audio.play(); btnSound.textContent='üîä'; } }
function toggleSound(){ if(!audioReady) return; if(audio.isPlaying){ audio.pause(); btnSound.textContent='üîà'; } else { listener.context.resume?.(); audio.play(); btnSound.textContent='üîä'; } }

wStart.addEventListener('click', ()=>{ listener.context.resume?.(); if(cfg.animation?.start==='onStart') playAnim(); if(cfg.audio?.url && cfg.audio.autoplay==='auto') playSound(); welcome.hidden=true; $('#hud').hidden=false; });
renderer.domElement.addEventListener('pointerdown', ()=>{ if(cfg.animation?.start==='onClick') playAnim(); });

btnPlay.addEventListener('click', ()=>{ if(!action) return; if(playing){ pauseAnim(); } else { playAnim(); } });
btnReplay.addEventListener('click', ()=>{ if(!action) return; action.reset(); playCount=0; playAnim(true); });
btnSound.addEventListener('click', toggleSound);

// Loop
renderer.setAnimationLoop(()=>{
  const dt = clock.getDelta(); mixer?.update(dt); controls.update(); renderer.render(scene, camera);
});
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
</script>
</body>
</html>
```

---

## 2) Patches ‚Äî `area-editor/index.html`

### 2.1 UI: neue Option im Anchor-Select

Im `<select id="anchorMode" ‚Ä¶>` **eine Option erg√§nzen** (unter ‚ÄûNative‚Äú):

```html
<option value="scene-viewer">Szene Viewer (ohne AR)</option>
```

---

### 2.2 Helfer einf√ºgen (Poster, Audio, Clip-Wahl)

> **Suche** im `<script type="module">` nach `async function exportSceneGLB()` und **f√ºge direkt dar√ºber** ein:

```js
// === Poster aus Canvas (JPEG) ===
async function capturePosterBlob(quality=0.9){
  const c = renderer.domElement;
  const dataUrl = c.toDataURL('image/jpeg', quality);
  const res = await fetch(dataUrl);
  return await res.blob(); // type image/jpeg
}

// === Erstes Audio-Objekt in der Szene (optional) ===
function findFirstAudio(){
  for (const rec of state.objects){
    if (rec.media?.kind === 'audio'){
      const fromFile = rec.file instanceof File ? rec.file : null;
      const fromDataUrl = (!fromFile && rec.media?.src && rec.media.src.startsWith('data:')) ? rec.media.src : null;
      return { rec, fromFile, fromDataUrl, loop: !!rec.media.loop, repeats: rec.media.repeats||1 };
    }
  }
  return null;
}
async function dataUrlToBlob(u){ const r = await fetch(u); return await r.blob(); }

// === Anim-Clip aus aktueller Auswahl ===
function getSelectedClipNameForExport(){
  if (state.selection.size === 1){
    const rec = state.objects.find(o=>o.id===state.selectedId);
    if (rec?.clips?.length){
      const idx = parseInt(document.getElementById('animClip').value||'0',10) || 0;
      const clip = rec.clips[idx] || rec.clips[0];
      return (clip?.name)||null;
    }
  }
  return "*"; // default: erster Clip
}
```

---

### 2.3 Export: Animationen in den GLB √ºbernehmen

> **Ersetze** deine `exportSceneGLB()`-Funktion vollst√§ndig durch:

```js
async function exportSceneGLB(){
  const exporter = new GLTFExporter();
  const exportRoot = cloneForExport();

  // alle Clips einsammeln (f√ºr den Export)
  const allClips = [];
  state.objects.forEach(r => { if (r?.clips?.length) r.clips.forEach(c => allClips.push(c)); });

  return new Promise((resolve, reject)=>{
    exporter.parse(
      exportRoot,
      (result)=>{
        try{
          if (result instanceof ArrayBuffer || ArrayBuffer.isView(result)){
            const ab = (result instanceof ArrayBuffer) ? result : result.buffer;
            return resolve(new Blob([ab], { type:'model/gltf-binary' }));
          }
          const glbBlob = makeGLBFromJSON(result);
          resolve(glbBlob);
        }catch(e){ reject(e); }
      },
      { binary:true, onlyVisible:true, embedImages:true, animations: allClips }
    );
  });
}
```

---

### 2.4 scene.json f√ºr ‚ÄûScene Viewer‚Äú erzeugen

> **F√ºge** (z.‚ÄØB. unter `buildSceneJSON`) diese Funktion ein:

```js
function buildSceneViewerJSON_CF({ sceneId, workerOrigin }){
  const base = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}`;
  const clipName = getSelectedClipNameForExport();
  const audio = findFirstAudio();

  return {
    ui: {
      showGround: true,
      autocenter: true,
      welcome: {
        eyebrow: "ARea ‚Äì Szene",
        title: projectName || sceneId,
        desc: "Klicke auf OK, um zu starten.",
        cta: "OK",
        poster: `${base}/poster.jpg`
      }
    },
    camera: { fov: 50, start:[2.2,1.6,3.0], lookAt:[0,1.1,0] },
    model:  { url: `${base}/scene.glb`, scale: 1, rotateY: 0 },
    animation: {
      enabled: true,
      clipName,
      start: "onStart",           // onStart | onClick | button
      loop: (document.getElementById('animLoop')?.value||'repeat') === 'repeat',
      iterations: parseInt(document.getElementById('animRepeats')?.value||'9999',10)||9999,
      clampWhenFinished: true,
      crossfade: 0.25,
      timeScale: 1
    },
    audio: audio ? {
      url: `${base}/audio.mp3`,
      autoplay: "withAnimation",  // oder "auto" / "button"
      loop: !!audio.loop,
      volume: 0.85
    } : { url: "" },
    triggers: { buttonLabel: "Animation abspielen", clickAnywhere: false }
  };
}
```

---

### 2.5 `publish()` erweitern (Scene Viewer Branch)

> In deiner `publish()` ersetze den Block **ab** `const mode = ...` **bis vor** dem `fetch(EP, ‚Ä¶)` durch:

```js
const mode = (document.getElementById('anchorMode')?.value || 'surface-webxr');
const workerOrigin = new URL(EP).origin;
const sceneBase    = `${workerOrigin}/scenes/${sceneId}/`;

let viewerUrl;
const form = new FormData();
form.append('sceneId', sceneId);

// GLB immer anh√§ngen
form.append('file', new File([glbBlob], 'scene.glb', { type:'model/gltf-binary' }));

if (mode === 'scene-viewer'){
  // Poster & optional Audio
  const posterBlob = await capturePosterBlob(0.9);
  form.append('file', new File([posterBlob], 'poster.jpg', { type:'image/jpeg' }));

  const audio = findFirstAudio();
  if (audio){
    const audioBlob = audio.fromFile ? audio.fromFile : (audio.fromDataUrl ? await dataUrlToBlob(audio.fromDataUrl) : null);
    if (audioBlob){
      const mime = (audioBlob.type||'audio/mpeg');
      form.append('file', new File([audioBlob], 'audio.mp3', { type: mime }));
    }
  }

  // Scene-Viewer-Config
  const sceneJson = buildSceneViewerJSON_CF({ sceneId, workerOrigin });
  form.append('file', new File([JSON.stringify(sceneJson,null,2)], 'scene.json', { type:'application/json' }));

} else {
  // Bestehende Viewer (WebXR / Native / Image)
  const glbUrl    = (mode === 'native' && (document.getElementById('nativeGlbUrl')?.value||'').trim())
                      ? (document.getElementById('nativeGlbUrl').value.trim())
                      : (sceneBase + 'scene.glb');
  const usdzUrl   = (mode === 'native' && (document.getElementById('nativeUsdzUrl')?.value||'').trim())
                      ? (document.getElementById('nativeUsdzUrl').value.trim())
                      : null;
  const targetUrl = (mode === 'image'  && (document.getElementById('imageTargetUrl')?.value||'').trim())
                      ? (document.getElementById('imageTargetUrl').value.trim())
                      : null;

  const sceneJson = buildSceneJSON({ sceneId, title: projectName, mode, glbUrl, usdzUrl, targetUrl });
  form.append('file', new File([JSON.stringify(sceneJson,null,2)], 'scene.json', { type:'application/json' }));
}
```

> **Unver√§ndert** bleiben anschlie√üend dein `fetch(EP, ‚Ä¶)` sowie die Erfolgsauswertung ‚Äì **erg√§nze nur die Ziel-URL** um den neuen Pfad:

```js
const viewerBase = (window.__AREA||{}).VIEWER_BASE || 'https://area-viewer.pages.dev';
const entryByMode = {
  'surface-webxr': '/webxr.html',
  'native':        '/index.html',
  'image':         '/image-ar/viewer.html',
  'scene-viewer':  '/scene-viewer/index.html' // ‚Üê NEU
};
const entry = entryByMode[mode] || '/webxr.html';
const viewerUrl = json.viewerUrl || `${viewerBase}${entry}?scene=${encodeURIComponent(sceneId)}&base=${encodeURIComponent(workerOrigin)}`;
```

---

## 3) Ergebnis & Aufruf

Nach dem Publish (Modus **‚ÄûSzene Viewer‚Äú**) bekommst du den Link:

```
https://area-viewer.pages.dev/scene-viewer/index.html?scene=<ID>&base=https://area-publish.area-webar.workers.dev
```

* **Welcome-Kachel** erscheint (Poster = Canvas-Snapshot)
* Klick ‚ÄûOK‚Äú ‚Üí **Animation** startet (endlos oder `iterations`-gez√§hlt)
* **Audio** spielt je nach Modus (Default: `withAnimation`)

> Debug/Fallback zu jsDelivr brauchst du nicht ‚Äì Cloudflare bleibt die Standard-Quelle, so wie im Projekt vorgesehen.
