<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Surface AR – WebXR Hit-Test (mit Animation)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui}
  #enter{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:12px;border:1px solid #555;background:#111;color:#fff}
  #msg{position:fixed;left:12px;bottom:12px;opacity:.9;background:rgba(0,0,0,.4);padding:6px 8px;border-radius:8px;max-width:min(92vw,780px);font:12px/1.35 system-ui;white-space:pre-wrap}
  #err{position:fixed;left:12px;top:12px;z-index:9;background:#b00020;color:#fff;padding:8px 10px;border-radius:8px;display:none;font:12px/1.35 monospace;max-width:min(92vw,680px);white-space:pre-wrap}
  #badge{position:fixed;right:12px;top:12px;z-index:9;background:#0b1220;color:#9cf;padding:6px 8px;border-radius:8px;font:12px system-ui}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
  <div id="err"></div>
  <button id="enter">Start AR</button>
  <div id="msg">Android Chrome empfohlen · Tippe auf den Boden, um das Modell zu platzieren</div>
  <div id="badge">WEBXR BUILD</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }  from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

let camera, scene, renderer, reticle, controller, hitTestSource=null, hitTestSourceRequested=false;
let model=null, mixer=null, clips=[];
const clock = new THREE.Clock();

const showErr = (m)=>{ const el=document.getElementById('err'); el.textContent=m; el.style.display='block'; };

/* ========= Param-Normalisierung ========= */
const qs = new URLSearchParams(location.search);
  // --- Force-Param: niemals auf Native umleiten, wenn ?force=webxr ---
const FORCE = (qs.get('force') || '').toLowerCase();
if (FORCE === 'webxr') {
  window.__FORCE_MODE = 'webxr';
  window.__NO_NATIVE_REDIRECT__ = true;   // falls irgendwo (global) Redirect-Logik existiert
  try { document.getElementById('badge').textContent = 'WEBXR (forced)'; } catch {}
}
let sceneParam = (qs.get('scene') || qs.get('src') || '').trim();
const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/, '');
const overrideGlb = (qs.get('glb') || '').trim();

const isHttp     = u => /^https?:\/\//i.test(u);
const isDataOrBlob = u => /^data:|^blob:/i.test(u);
const isGlbLike  = u => /\.(?:glb|gltf)(?:[?#]|$)/i.test(u);

let SCENE_GLB = '';
let SCENE_JSON = '';

if (overrideGlb) {
  SCENE_GLB = overrideGlb;
} else if (sceneParam) {
  if (isDataOrBlob(sceneParam)) {
    SCENE_JSON = sceneParam;
  } else if (isHttp(sceneParam)) {
    if (isGlbLike(sceneParam)) SCENE_GLB = sceneParam;
    else SCENE_JSON = sceneParam;
  } else {
    const id = sceneParam.replace(/\/+$/,'');
    SCENE_GLB  = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.glb`;
    SCENE_JSON = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.json`;
  }
}

const cfg = {
  modelUrl: SCENE_GLB || 'https://modelviewer.dev/shared-assets/models/Astronaut.glb',
  position: [0,0,0],
  rotation: [0,0,0],  // Grad
  scale:[0.6,0.6,0.6],
  animation: '*',     // '*', 'none', Name oder Index
  animSpeed: 1.0,
  animLoop: 'loop',   // 'loop' | 'once' | 'pingpong'
  animRepetitions: Infinity,
  animClamp: true     // relevant für 'once'
};

// ---------- Utils ----------
const rad2deg = r => (r||0) * 180/Math.PI;
const deg2rad = d => (d||0) * Math.PI/180;

// ---------- Szene aus externer JSON (optional) ----------
async function loadScene(){
  if (SCENE_GLB) { cfg.modelUrl = SCENE_GLB; return; }
  if (!SCENE_JSON) return;

  try{
    const r = await fetch(SCENE_JSON, {cache:'no-cache', mode:'cors'});
    if(!r.ok) throw new Error('scene.json Load '+r.status+' '+r.statusText);
    const j = await r.json();

    const resolveAgainstJson = (u)=>{
      if (!u) return u;
      if (isHttp(u) || isDataOrBlob(u)) return u;
      try { return new URL(u, SCENE_JSON).href; } catch { return u; }
    };

    if (j?.model?.url)                cfg.modelUrl = resolveAgainstJson(j.model.url);
    if (Array.isArray(j?.model?.position))    cfg.position = j.model.position;
    if (Array.isArray(j?.model?.rotationDeg)) cfg.rotation = j.model.rotationDeg;
    else if (Array.isArray(j?.model?.rotation)) cfg.rotation = j.model.rotation;
    if (Array.isArray(j?.model?.scale))       cfg.scale    = j.model.scale;
    if (j?.model?.animation != null)          cfg.animation= j.model.animation;

    // optionale Animation-Extras aus scene.json
    if (j?.model?.animSpeed != null)          cfg.animSpeed = +j.model.animSpeed || 1.0;
    if (j?.model?.animLoop)                   cfg.animLoop = String(j.model.animLoop).toLowerCase();
    if (j?.model?.animRepetitions != null)    cfg.animRepetitions = +j.model.animRepetitions;
    if (j?.model?.animClamp != null)          cfg.animClamp = !!j.model.animClamp;

  }catch(e){
    console.warn(e);
    showErr('scene.json konnte nicht geladen werden:\n'+e.message);
  }
}

// -------- Fallbacks aus Query --------
function applyQueryFallback(){
  const glb = qs.get('glb');
  if (glb) cfg.modelUrl = glb;

  const rx = qs.get('rx'), ry = qs.get('ry'), rz = qs.get('rz');
  if (rx!=null || ry!=null || rz!=null){
    cfg.rotation = [rad2deg(parseFloat(rx)), rad2deg(parseFloat(ry)), rad2deg(parseFloat(rz))].map(v=>isFinite(v)?v:0);
  }

  const px = parseFloat(qs.get('px')), py = parseFloat(qs.get('py')), pz = parseFloat(qs.get('pz'));
  if ([px,py,pz].some(v=>!isNaN(v))) cfg.position = [px||0, py||0, pz||0];

  const sx = parseFloat(qs.get('sx')), sy = parseFloat(qs.get('sy')), sz = parseFloat(qs.get('sz'));
  if ([sx,sy,sz].some(v=>!isNaN(v))) cfg.scale = [sx||1, sy||1, sz||1];

  // Animation via Query
  const anim = qs.get('anim');
  if (anim !== null) {
    // "*" | "none" | name | index
    const asNum = Number(anim);
    cfg.animation = (anim === '*' || anim === 'none' || Number.isNaN(asNum)) ? anim : asNum;
  }
  const animSpeed = parseFloat(qs.get('animSpeed'));
  if (!Number.isNaN(animSpeed)) cfg.animSpeed = animSpeed;

  const animLoop = (qs.get('animLoop') || '').toLowerCase();
  if (animLoop) cfg.animLoop = animLoop;

  const animReps = parseFloat(qs.get('animReps'));
  if (!Number.isNaN(animReps)) cfg.animRepetitions = animReps;

  const animClamp = qs.get('animClamp');
  if (animClamp !== null) cfg.animClamp = /^(1|true|yes|on)$/i.test(animClamp);
}

// ---------- THREE Init ----------
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(0,6,0); scene.add(dir);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // Reticle
  const ring = new THREE.RingGeometry(0.07, 0.08, 32).rotateX(-Math.PI/2);
  const mat = new THREE.MeshBasicMaterial({color:0x66ccff});
  reticle = new THREE.Mesh(ring, mat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  addEventListener('resize', ()=>renderer.setSize(innerWidth, innerHeight));
  document.getElementById('enter').addEventListener('click', startAR);

  try { window.opener && window.opener.postMessage({ type:'webar-ready' }, location.origin); } catch {}
}

// ---------- Model-Animation ----------
function configureAction(action){
  const loop = (cfg.animLoop||'loop').toLowerCase();
  let mode = THREE.LoopRepeat, reps = Infinity;

  if (loop === 'once') {
    mode = THREE.LoopOnce; reps = 1;
    action.clampWhenFinished = cfg.animClamp !== false;
  } else if (loop === 'pingpong') {
    mode = THREE.LoopPingPong; reps = Infinity;
  }

  const finalReps = Number.isFinite(cfg.animRepetitions) ? cfg.animRepetitions : reps;
  action.setLoop(mode, finalReps);
  action.timeScale = cfg.animSpeed || 1.0;
  return action;
}

function playClips(){
  if (!mixer || !clips.length) return;
  const a = cfg.animation;
  if (a==='none') return;

  // Stoppe evtl. vorherige Aktionen
  mixer.stopAllAction();

  if (a==='*'){
    clips.forEach(c=>configureAction(mixer.clipAction(c)).play());
  } else if (typeof a==='string'){
    const c = clips.find(c=>c.name===a) || clips[0];
    if (c) configureAction(mixer.clipAction(c)).play();
  } else {
    const idx = Math.max(0, Math.min(clips.length-1, parseInt(a||0,10)));
    const c = clips[idx];
    if (c) configureAction(mixer.clipAction(c)).play();
  }
}

/* ---------- Flexible GLB/GLTF Loader ---------- */
async function loadGLTFFlexible(url) {
  const res = await fetch(url, { mode: 'cors', credentials: 'omit' });
  if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

  const ct = (res.headers.get('content-type') || '').toLowerCase();
  const looksGLB = /\.glb(?:[?#]|$)/i.test(url) || ct.includes('model/gltf-binary') || ct.includes('application/octet-stream');

  const loader = new GLTFLoader();
  loader.setCrossOrigin('anonymous');
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(draco);

  if (looksGLB) {
    const buf = await res.arrayBuffer();
    return new Promise((resolve, reject)=>
      loader.parse(buf, '', gltf=>resolve(gltf), err=>reject(err))
    );
  } else {
    const text = await res.text();
    let json;
    try { json = JSON.parse(text); }
    catch (e) { showErr('GLTF-JSON konnte nicht geparst werden.'); throw e; }
    const base = url.replace(/[^\/?#]*([?#].*)?$/, '');
    return new Promise((resolve, reject)=>
      loader.parse(json, base, gltf=>resolve(gltf), err=>reject(err))
    );
  }
}

/* ---------- Tap: platzieren & laden ---------- */
async function onSelect() {
  if (!reticle.visible) return;

  if (!model) {
    try {
      const gltf = await loadGLTFFlexible(cfg.modelUrl);
      model = gltf.scene;
      const [sx,sy,sz] = cfg.scale;    model.scale.set(sx,sy,sz);
      const [rx,ry,rz] = cfg.rotation; model.rotation.set(deg2rad(rx), deg2rad(ry), deg2rad(rz));
      model.position.setFromMatrixPosition(reticle.matrix);
      scene.add(model);

      clips = gltf.animations || [];
      if (clips.length) {
        mixer = new THREE.AnimationMixer(model);
        playClips();

        // Info-Overlay mit verfügbaren Animationen
        try {
          const names = clips.map(c=>c.name||'(unnamed)').join(', ');
          const info = names ? ` · Animationen: ${names}` : ' · Keine Animationen im GLTF';
          document.getElementById('msg').textContent += info;
        } catch {}
      }
    } catch (err) {
      console.error('GLTF load failed', err);
      showErr('Fehler beim Laden des Objekts:\n' + (err?.message || err || 'Unbekannt'));
    }
  } else {
    model.position.setFromMatrixPosition(reticle.matrix);
  }
}

// ---------- WebXR ----------
async function startAR(){
  if (!navigator.xr) { showErr('WebXR nicht verfügbar.'); return; }
  const isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
  if (!isARSupported) { showErr('Dein Gerät/Browser unterstützt kein WebXR-AR.'); return; }
  const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test','local-floor'] });
  renderer.xr.setReferenceSpaceType('local-floor');
  await renderer.xr.setSession(session);
  document.getElementById('enter').style.display='none';
  animate();
}

function animate() { renderer.setAnimationLoop(render); }

function render(t, frame) {
  const dt = clock.getDelta(); if (mixer) mixer.update(dt);
  if (!frame){ renderer.render(scene, camera); return; }
  const referenceSpace = renderer.xr.getReferenceSpace();
  const session = renderer.xr.getSession();

  if (!hitTestSourceRequested) {
    session.requestReferenceSpace('viewer').then((viewerSpace) => {
      session.requestHitTestSource({ space: viewerSpace }).then((source) => { hitTestSource = source; });
    });
    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
    hitTestSourceRequested = true;
  }

  if (hitTestSource) {
    const results = frame.getHitTestResults(hitTestSource);
    if (results.length) {
      const hit = results[0];
      const pose = hit.getPose(referenceSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else { reticle.visible = false; }
  }

  renderer.render(scene, camera);
}

// ---------- Boot ----------
(async ()=>{
  try{ await loadScene(); }catch(e){ console.warn(e); }
  applyQueryFallback();
  init();
})();
</script>
</body>
</html>
