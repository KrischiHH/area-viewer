<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARea Viewer – WebXR Hit-Test (mit Animation)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui}
  #welcome{position:fixed;inset:0;z-index:99;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px}
  #welcome.hidden{display:none}
  #welcomePoster{max-width:90%;max-height:40vh;object-fit:contain;margin-bottom:20px;border-radius:8px}
  #welcomeEyebrow{font-size:12px;color:#9cf;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px}
  #welcomeTitle{font-size:24px;font-weight:600;margin-bottom:8px;text-align:center}
  #welcomeDesc{font-size:14px;color:#ccc;margin-bottom:20px;text-align:center;max-width:400px}
  #welcomeBtn{padding:12px 24px;border-radius:12px;border:1px solid #555;background:#111;color:#fff;font-size:16px;cursor:pointer}
  #welcomeBtn:hover{background:#222}
  #nativeCta{margin-top:12px;padding:10px 20px;border-radius:10px;border:1px solid #555;background:#111;color:#fff;font-size:14px;cursor:pointer;display:none}
  #nativeCta:hover{background:#222}
  #diagnostics{margin-top:16px;font-size:12px;color:#f88;text-align:center;display:none}
  #enter{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:12px;border:1px solid #555;background:#111;color:#fff;display:none}
  #msg{position:fixed;left:12px;bottom:12px;opacity:.9}
  #err{position:fixed;left:12px;top:12px;z-index:9;background:#b00020;color:#fff;padding:8px 10px;border-radius:8px;display:none;font:12px/1.35 monospace;max-width:min(92vw,680px);white-space:pre-wrap}
  #badge{position:fixed;right:12px;top:12px;z-index:9;background:#0b1220;color:#9cf;padding:6px 8px;border-radius:8px;font:12px system-ui}
  #hud{position:fixed;right:12px;bottom:12px;z-index:9;display:none;flex-wrap:wrap;gap:6px;background:rgba(0,0,0,.4);border:1px solid rgba(255,255,255,.15);padding:8px;border-radius:12px;backdrop-filter:blur(6px);max-width:90vw}
  #hud button{all:unset;cursor:pointer;color:#fff;padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:#111;font-size:13px;white-space:nowrap}
  #hud button:hover{background:#222}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
  <div id="welcome">
    <img id="welcomePoster" style="display:none"/>
    <div id="welcomeEyebrow"></div>
    <div id="welcomeTitle"></div>
    <div id="welcomeDesc"></div>
    <button id="welcomeBtn">Start AR</button>
    <button id="nativeCta">Open in Native AR</button>
    <div id="diagnostics"></div>
  </div>
  <div id="err"></div>
  <button id="enter">Start AR</button>
  <div id="msg">Android Chrome empfohlen · Tippe auf den Boden, um das Modell zu platzieren</div>
  <div id="badge">WEBXR BUILD</div>
  <div id="hud">
    <button id="btnScaleUp">Scale +10%</button>
    <button id="btnScaleDown">Scale -10%</button>
    <button id="btnRotLeft">Rotate -15°</button>
    <button id="btnRotRight">Rotate +15°</button>
    <button id="btnReset">Reset</button>
    <button id="btnPlay" style="display:none">Play/Pause</button>
    <button id="btnMute" style="display:none">Mute</button>
  </div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }  from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

let camera, scene, renderer, reticle, controller, hitTestSource=null, hitTestSourceRequested=false;
let model=null, ghost=null, mixer=null, clips=[], audioListener=null, audio=null, loadedGltf=null;
const clock = new THREE.Clock();
let cfg = null; // Will be populated by loadConfig + normalizeCfg
let __base = ''; // Base URL for resolving relative paths
let placed = false; // Track if model has been placed
let initialScale = 1.0; // Store initial scale for reset
let initialRotation = 0; // Store initial rotation for reset

const showErr = (m)=>{ const el=document.getElementById('err'); el.textContent=m; el.style.display='block'; console.error(m); };
const log = (...a)=>{ try{ console.log('[area-viewer]', ...a); }catch{} };

/* ========= Config Loading & Normalization ========= */
const qs = new URLSearchParams(location.search);
const FORCE = (qs.get('force') || '').toLowerCase();
if (FORCE === 'webxr') {
  try { document.getElementById('badge').textContent = 'WEBXR (forced)'; } catch {}
}

const isHttp     = u => /^https?:\/\//i.test(u);
const isDataOrBlob = u => /^data:|^blob:/i.test(u);
const isGlbLike  = u => /\.(?:glb|gltf)(?:[?#]|$)/i.test(u);

// 1) loadConfig(): robust scene config loading
async function loadConfig() {
  const sceneParam = (qs.get('scene') || qs.get('src') || '').trim();
  const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/, '');
  const overrideGlb = (qs.get('glb') || '').trim();

  // Backwards compatibility: If only GLB URL provided, run without scene.json
  if (overrideGlb && !sceneParam) {
    log('Backwards compat: GLB only mode');
    return { model: { url: overrideGlb, scale: 1.0 } };
  }

  if (!sceneParam) {
    // No config, use defaults
    return { model: { url: 'https://modelviewer.dev/shared-assets/models/Astronaut.glb', scale: 1.0 } };
  }

  // Parse scene parameter
  if (sceneParam.startsWith('data:')) {
    // data URI - decode base64 or plain JSON
    try {
      const match = sceneParam.match(/^data:(?:application\/json)?;base64,(.+)$/);
      if (match) {
        const json = atob(match[1]);
        return JSON.parse(json);
      } else {
        const match2 = sceneParam.match(/^data:(?:application\/json)?,(.+)$/);
        if (match2) return JSON.parse(decodeURIComponent(match2[1]));
      }
      return JSON.parse(sceneParam.replace(/^data:(?:application\/json)?,/, ''));
    } catch (e) {
      showErr('Failed to parse data URI: ' + e.message);
      return { model: { url: '', scale: 1.0 } };
    }
  } else if (isHttp(sceneParam)) {
    // URL - fetch scene.json
    try {
      // URLSearchParams already decodes the parameter, so don't decode again
      const srcUrl = sceneParam;
      const r = await fetch(srcUrl, {cache:'no-cache', mode:'cors'});
      if (!r.ok) throw new Error('HTTP ' + r.status + ' ' + r.statusText);
      const json = await r.json();
      // Set __base from directory
      __base = srcUrl.replace(/[^\/]*$/, '');
      log('Loaded scene.json from URL, base:', __base);
      return json;
    } catch (e) {
      showErr('Failed to load scene.json: ' + e.message);
      return { model: { url: '', scale: 1.0 } };
    }
  } else {
    // Scene ID - construct URLs with worker base
    const id = sceneParam.replace(/\/+$/,'');
    __base = `${workerBase}/scenes/${encodeURIComponent(id)}/`;
    const sceneJsonUrl = __base + 'scene.json';
    try {
      const r = await fetch(sceneJsonUrl, {cache:'no-cache', mode:'cors'});
      if (!r.ok) throw new Error('HTTP ' + r.status + ' ' + r.statusText);
      const json = await r.json();
      log('Loaded scene.json for ID:', id, 'base:', __base);
      return json;
    } catch (e) {
      showErr('Failed to load scene.json for ID ' + id + ': ' + e.message);
      return { model: { url: '', scale: 1.0 } };
    }
  }
}

// Resolve relative URLs against __base
function resolveUrl(url) {
  if (!url) return url;
  if (isHttp(url) || isDataOrBlob(url)) return url;
  if (__base) {
    try { return new URL(url, __base).href; } catch {}
  }
  return url;
}

// 2) normalizeCfg(): backfills + defaults
function normalizeCfg(raw) {
  const c = {
    meta: raw.meta || {},
    model: raw.model || {},
    animation: raw.animation || {},
    audio: raw.audio || {},
    ui: raw.ui || {}
  };

  // Backfill legacy fields
  if (!c.audio.url && raw.audio?.src) c.audio.url = raw.audio.src;
  if (!c.ui.welcome) c.ui.welcome = {};
  if (!c.ui.welcome.poster && raw.target?.previewUrl) c.ui.welcome.poster = raw.target.previewUrl;

  // Resolve URLs
  if (c.model.url) c.model.url = resolveUrl(c.model.url);
  if (c.model.usdzUrl) c.model.usdzUrl = resolveUrl(c.model.usdzUrl);
  if (c.audio.url) c.audio.url = resolveUrl(c.audio.url);
  if (c.ui.welcome.poster) c.ui.welcome.poster = resolveUrl(c.ui.welcome.poster);

  // Defaults
  if (!c.model.scale) c.model.scale = 1.0;
  if (!c.animation.start) c.animation.start = 'onPlace';
  if (!c.animation.clipName) c.animation.clipName = '*';
  if (c.animation.loop == null) c.animation.loop = true;
  if (!c.animation.iterations) c.animation.iterations = 9999;
  if (!c.audio.autoplay) c.audio.autoplay = 'withAnimation';
  if (c.audio.loop == null) c.audio.loop = true;
  if (!c.audio.volume) c.audio.volume = 0.85;

  log('Normalized config:', c);
  return c;
}

// 3) Poster/Welcome overlay and session start
function setupWelcomeScreen() {
  const welcome = document.getElementById('welcome');
  const poster = document.getElementById('welcomePoster');
  const eyebrow = document.getElementById('welcomeEyebrow');
  const title = document.getElementById('welcomeTitle');
  const desc = document.getElementById('welcomeDesc');
  const btn = document.getElementById('welcomeBtn');
  const nativeCta = document.getElementById('nativeCta');
  const diagnostics = document.getElementById('diagnostics');

  // Check if we have backwards compat mode (no welcome config)
  if (!cfg.ui?.welcome || (!cfg.ui.welcome.poster && !cfg.ui.welcome.title && !cfg.ui.welcome.desc)) {
    // Backwards compatibility: no welcome screen, just show start button
    welcome.classList.add('hidden');
    document.getElementById('enter').style.display = 'block';
    document.getElementById('enter').addEventListener('click', startAR);
    return;
  }

  // Populate welcome screen
  if (cfg.ui.welcome.poster) {
    poster.src = cfg.ui.welcome.poster;
    poster.style.display = 'block';
  }
  if (cfg.ui.welcome.eyebrow) eyebrow.textContent = cfg.ui.welcome.eyebrow;
  if (cfg.ui.welcome.title) title.textContent = cfg.ui.welcome.title;
  if (cfg.ui.welcome.desc) desc.textContent = cfg.ui.welcome.desc;

  // Check WebXR support
  checkWebXRSupport().then(supported => {
    if (supported) {
      btn.addEventListener('click', () => {
        welcome.classList.add('hidden');
        startAR();
      });
    } else {
      // 5) iOS/non-WebXR fallback with diagnostics and native CTA
      btn.style.display = 'none';
      diagnostics.textContent = 'WebXR is not supported on this device/browser.';
      diagnostics.style.display = 'block';
      
      const nativeCfg = cfg.ui.welcome.nativeCta || 'ios-only';
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      const hasUsdz = cfg.model.usdzUrl;
      const hasGlb = cfg.model.url;
      
      if ((hasUsdz || hasGlb) && (nativeCfg === 'always' || (nativeCfg === 'ios-only' && isIOS))) {
        nativeCta.style.display = 'block';
        nativeCta.addEventListener('click', () => {
          if (isIOS && hasUsdz) {
            // iOS Quick Look - prefers USDZ
            const a = document.createElement('a');
            a.rel = 'ar';
            a.href = cfg.model.usdzUrl;
            a.click();
          } else if (hasGlb) {
            // Android Scene Viewer Intent - uses GLB
            const intent = `intent://arvr.google.com/scene-viewer/1.0?file=${encodeURIComponent(cfg.model.url)}#Intent;scheme=https;package=com.google.android.googlequicksearchbox;action=android.intent.action.VIEW;S.browser_fallback_url=https://developers.google.com/ar;end;`;
            window.location.href = intent;
          }
        });
        });
      }
    }
  });
}

async function checkWebXRSupport() {
  if (!navigator.xr) return false;
  try {
    return await navigator.xr.isSessionSupported('immersive-ar');
  } catch {
    return false;
  }
}

// ---------- THREE Init ----------
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(0,6,0); scene.add(dir);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // Audio setup
  if (cfg.audio?.url) {
    audioListener = new THREE.AudioListener();
    camera.add(audioListener);
    audio = new THREE.Audio(audioListener);
    const audioLoader = new THREE.AudioLoader();
    audioLoader.load(cfg.audio.url, (buffer) => {
      audio.setBuffer(buffer);
      audio.setLoop(cfg.audio.loop);
      audio.setVolume(cfg.audio.volume);
      log('Audio loaded:', cfg.audio.url);
    }, undefined, (err) => {
      console.warn('Audio load failed:', err);
    });
  }

  // Reticle
  const ring = new THREE.RingGeometry(0.07, 0.08, 32).rotateX(-Math.PI/2);
  const mat = new THREE.MeshBasicMaterial({color:0x66ccff});
  reticle = new THREE.Mesh(ring, mat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  addEventListener('resize', ()=>{
    // Während XR presenting NICHT setSize aufrufen – das macht Three im XR-Loop selbst
    if (!renderer.xr.isPresenting) {
      renderer.setSize(innerWidth, innerHeight);
    }
  });

  setupHUD();
  setupWelcomeScreen();
}

// 9) HUD (DOM overlay) setup
function setupHUD() {
  const hud = document.getElementById('hud');
  const btnScaleUp = document.getElementById('btnScaleUp');
  const btnScaleDown = document.getElementById('btnScaleDown');
  const btnRotLeft = document.getElementById('btnRotLeft');
  const btnRotRight = document.getElementById('btnRotRight');
  const btnReset = document.getElementById('btnReset');
  const btnPlay = document.getElementById('btnPlay');
  const btnMute = document.getElementById('btnMute');

  // Scale buttons
  btnScaleUp.addEventListener('click', () => {
    if (!model) return;
    model.scale.multiplyScalar(1.1);
  });

  btnScaleDown.addEventListener('click', () => {
    if (!model) return;
    model.scale.multiplyScalar(0.9);
  });

  // Rotate buttons
  btnRotLeft.addEventListener('click', () => {
    if (!model) return;
    model.rotation.y -= Math.PI / 12; // -15 degrees
  });

  btnRotRight.addEventListener('click', () => {
    if (!model) return;
    model.rotation.y += Math.PI / 12; // +15 degrees
  });

  // Reset button - return to pre-placement ghost state
  btnReset.addEventListener('click', () => {
    if (!model) return;
    placed = false;
    scene.remove(model);
    model = null;
    if (ghost) ghost.visible = true;
    hud.style.display = 'none';
    if (mixer) {
      mixer.stopAllAction();
      mixer = null;
    }
    if (audio && audio.isPlaying) {
      try { audio.stop(); } catch (e) { console.warn('Audio stop failed:', e); }
    }
  });

  // Play/Pause button - only visible when animation.start == "manual"
  if (cfg.animation?.start === 'manual') {
    btnPlay.style.display = 'block';
    btnPlay.addEventListener('click', () => {
      if (!mixer) return;
      if (!mixer._started) {
        startSelectedClip();
        mixer._started = true;
      } else {
        // Toggle time scale
        mixer.timeScale = mixer.timeScale === 0 ? 1 : 0;
        
        // Sync audio with animation
        if (audio && cfg.audio.autoplay === 'withAnimation') {
          if (mixer.timeScale === 1 && !audio.isPlaying) {
            try { audio.play(); } catch (e) { console.warn('Audio play failed:', e); }
          } else if (mixer.timeScale === 0 && audio.isPlaying) {
            try { audio.stop(); } catch (e) { console.warn('Audio stop failed:', e); }
          }
        }
      }
    });
  }

  // Mute button - only if audio exists
  if (cfg.audio?.url) {
    btnMute.style.display = 'block';
    let muted = false;
    btnMute.addEventListener('click', () => {
      if (!audio) return;
      muted = !muted;
      audio.setVolume(muted ? 0 : cfg.audio.volume);
      btnMute.textContent = muted ? 'Unmute' : 'Mute';
    });
  }
}

// ---------- Animation helpers ----------
function startSelectedClip() {
  if (!mixer || !clips.length) return;
  const sel = (cfg.animation.clipName || '*');
  if (sel === 'none') { log('Animation: none'); return; }

  // Clip wählen
  const clip = (sel === '*') ? clips[0] : (clips.find(c => c.name === sel) || clips[0]);
  if (!clip) { log('Keine Clips im GLB'); return; }

  mixer.stopAllAction();
  const act = mixer.clipAction(clip);
  if (cfg.animation.loop) {
    act.setLoop(THREE.LoopRepeat, cfg.animation.iterations || 9999);
  } else {
    act.setLoop(THREE.LoopOnce, 0);
    act.clampWhenFinished = true;
  }
  act.reset().play();
  mixer.timeScale = 1;
  log('Animation gestartet', { name: clip.name, loop: cfg.animation.loop, iters: cfg.animation.iterations });

  // Sync audio with animation
  if (audio && cfg.audio.autoplay === 'withAnimation') {
    if (!audio.isPlaying) {
      try { audio.play(); } catch (e) { console.warn('Audio play failed:', e); }
    }
  }
}

function stopAnimation() {
  if (!mixer) return;
  mixer.stopAllAction();
  mixer.timeScale = 0;
  
  // Sync audio with animation
  if (audio && cfg.audio.autoplay === 'withAnimation' && audio.isPlaying) {
    try { audio.stop(); } catch (e) { console.warn('Audio stop failed:', e); }
  }
}

/* ---------- GLB/GLTF Loader ---------- */
async function loadGLTFFlexible(url) {
  const res = await fetch(url, { mode: 'cors', credentials: 'omit' });
  if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

  const ct = (res.headers.get('content-type') || '').toLowerCase();
  const looksGLB = /\.glb(?:[?#]|$)/i.test(url) || ct.includes('model/gltf-binary') || ct.includes('application/octet-stream');

  const loader = new GLTFLoader();
  loader.setCrossOrigin('anonymous');
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(draco);

  if (looksGLB) {
    const buf = await res.arrayBuffer();
    return new Promise((resolve, reject)=>
      loader.parse(buf, '', gltf=>resolve(gltf), err=>reject(err))
    );
  } else {
    const text = await res.text();
    let json;
    try { json = JSON.parse(text); }
    catch (e) { showErr('GLTF-JSON konnte nicht geparst werden.'); throw e; }
    const base = url.replace(/[^\/?#]*([?#].*)?$/, '');
    return new Promise((resolve, reject)=>
      loader.parse(json, base, gltf=>resolve(gltf), err=>reject(err))
    );
  }
}

// 4) Placement: Load ghost model on session start
async function loadGhostModel() {
  if (!cfg.model?.url) return;
  
  try {
    loadedGltf = await loadGLTFFlexible(cfg.model.url);
    ghost = loadedGltf.scene.clone();
    
    // Apply scale
    const scale = cfg.model.scale || 1.0;
    ghost.scale.set(scale, scale, scale);
    initialScale = scale;
    
    // Make semi-transparent
    ghost.traverse((child) => {
      if (child.isMesh) {
        if (Array.isArray(child.material)) {
          child.material = child.material.map(mat => {
            const m = mat.clone();
            m.transparent = true;
            m.opacity = 0.5;
            return m;
          });
        } else {
          child.material = child.material.clone();
          child.material.transparent = true;
          child.material.opacity = 0.5;
        }
      }
    });
    
    ghost.visible = false;
    scene.add(ghost);
    
    // Store clips for later
    clips = loadedGltf.animations || [];
    log('GLB Clips', clips.map(c => ({ name: c.name, dur: c.duration.toFixed(2) })));
    
    // Start animation if mode is "onStart"
    if (cfg.animation?.start === 'onStart' && clips.length) {
      // We'll start the animation after placing the actual model
      log('Animation start mode: onStart (will start after model loads)');
    }
    
    // Start audio if autoplay is "onStart"
    if (audio && cfg.audio.autoplay === 'onStart') {
      try { audio.play(); } catch (e) { console.warn('Audio play failed:', e); }
      log('Audio autoplay: onStart');
    }
  } catch (err) {
    console.error('Ghost model load failed', err);
    showErr('Fehler beim Laden des Modells:\n' + (err?.message || err || 'Unbekannt'));
  }
}

/* ---------- Tap: platzieren & laden ---------- */
async function onSelect() {
  if (!reticle.visible) return;

  if (!model && !placed) {
    // First placement - convert ghost to real model
    if (!loadedGltf) {
      showErr('Modell konnte nicht geladen werden.');
      return;
    }
    
    try {
      // Use the already loaded GLTF
      model = loadedGltf.scene.clone();
      
      // Apply scale
      const scale = cfg.model.scale || 1.0;
      model.scale.set(scale, scale, scale);
      
      // Position at reticle
      model.position.setFromMatrixPosition(reticle.matrix);
      scene.add(model);
      
      // Hide ghost
      if (ghost) ghost.visible = false;
      placed = true;
      
      // Show HUD after placement
      document.getElementById('hud').style.display = 'flex';
      
      // Setup animation
      if (clips.length) {
        mixer = new THREE.AnimationMixer(model);
        
        // Start animation based on mode
        if (cfg.animation?.start === 'onPlace') {
          startSelectedClip();
          log('Animation started: onPlace mode');
        } else if (cfg.animation?.start === 'onStart') {
          // onStart means start as soon as session starts (after model loads)
          // Since we're placing after session start, start now
          startSelectedClip();
          log('Animation started: onStart mode (after placement)');
        } else if (cfg.animation?.start === 'manual') {
          // Manual mode - user controls via HUD
          log('Animation mode: manual (use HUD to control)');
        }
      } else {
        log('Keine Animationen im Modell gefunden.');
      }
      
      // Audio autoplay handling
      if (audio && cfg.audio.autoplay === 'withAnimation' && cfg.animation?.start !== 'manual') {
        // Audio starts with animation for non-manual modes
        if (!audio.isPlaying) {
          try { audio.play(); } catch (e) { console.warn('Audio play failed:', e); }
        }
      }
    } catch (err) {
      console.error('Model placement failed', err);
      showErr('Fehler beim Platzieren des Objekts:\n' + (err?.message || err || 'Unbekannt'));
    }
  } else if (model) {
    // Reposition existing model
    model.position.setFromMatrixPosition(reticle.matrix);
  }
}

// ---------- WebXR ----------
async function startAR() {
  if (!navigator.xr) { showErr('WebXR nicht verfügbar.'); return; }
  try {
    const isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
    if (!isARSupported) { showErr('Dein Gerät/Browser unterstützt kein WebXR-AR.'); return; }

    // Request session with DOM overlay for HUD
    const session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test', 'local-floor'],
      optionalFeatures: ['dom-overlay'],
      domOverlay: { root: document.body }
    });
    
    renderer.xr.setReferenceSpaceType('local-floor');
    await renderer.xr.setSession(session);
    
    // Load ghost model once session starts
    await loadGhostModel();
    
    animate();
  } catch (err) {
    console.error('XR session failed', err);
    showErr('WebXR-Sitzung konnte nicht gestartet werden:\n' + (err?.message || err));
  }
}

function animate() { renderer.setAnimationLoop(render); }

function render(t, frame) {
  const dt = clock.getDelta(); 
  if (mixer) mixer.update(dt);
  
  if (!frame) { 
    renderer.render(scene, camera); 
    return; 
  }
  
  const referenceSpace = renderer.xr.getReferenceSpace();
  const session = renderer.xr.getSession();

  if (!hitTestSourceRequested) {
    session.requestReferenceSpace('viewer').then((viewerSpace) => {
      session.requestHitTestSource({ space: viewerSpace }).then((source) => { 
        hitTestSource = source; 
      });
    });
    session.addEventListener('end', () => { 
      hitTestSourceRequested = false; 
      hitTestSource = null; 
    });
    hitTestSourceRequested = true;
  }

  if (hitTestSource) {
    const results = frame.getHitTestResults(hitTestSource);
    if (results.length) {
      const hit = results[0];
      const pose = hit.getPose(referenceSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
      
      // Update ghost position and rotation if not placed yet
      if (ghost && !placed) {
        ghost.visible = true;
        ghost.matrix.fromArray(pose.transform.matrix);
        ghost.matrix.decompose(ghost.position, ghost.quaternion, ghost.scale);
        // Restore the configured scale
        const scale = cfg.model.scale || 1.0;
        ghost.scale.set(scale, scale, scale);
      }
    } else { 
      reticle.visible = false;
      if (ghost && !placed) ghost.visible = false;
    }
  }

  renderer.render(scene, camera);
}

// ---------- Boot ----------
(async () => {
  try {
    const rawCfg = await loadConfig();
    cfg = normalizeCfg(rawCfg);
    log('Final config:', cfg);
    init();
  } catch (e) {
    console.error('Boot failed:', e);
    showErr('Initialisierung fehlgeschlagen:\n' + (e?.message || e));
  }
})();
</script>
</body>
</html>
