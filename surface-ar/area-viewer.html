<!doctype html>
<html lang="de" class="theme-slate">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ARea Viewer ‚Äì Animation Fixed</title>
  <style>
    :root { color-scheme: dark; }
    :root.theme-slate{
      --bg:#0b1020; --panel:#10172a; --text:#e6edf3; --muted:#94a3b8; --accent:#5b9dff; --border:#20304b;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #app { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }
    .hud {
      position:fixed; inset:16px auto auto 16px; padding:10px 12px;
      background:color-mix(in hsl, var(--panel) 88%, transparent);
      border:1px solid var(--border); border-radius:12px; backdrop-filter: blur(8px);
      box-shadow: 0 6px 24px rgba(0,0,0,.25); font-size:14px; user-select:none;
      max-width: 400px;
    }
    .hud code{ padding:.15em .4em; background:#0006; border:1px solid #ffffff1a; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tapgate {
      position:fixed; inset:0; display:none; place-items:center; z-index:20;
      background:linear-gradient(180deg, rgba(7,12,24,.75), rgba(7,12,24,.85));
      color:var(--text);
    }
    .tapgate.show { display:grid; }
    .card {
      width:min(520px, 92vw); padding:20px; border-radius:16px; border:1px solid var(--border);
      background:color-mix(in hsl, var(--panel) 92%, transparent);
      box-shadow: 0 10px 30px rgba(0,0,0,.35); text-align:center;
    }
    .btn {
      display:inline-flex; align-items:center; gap:.5rem; margin-top:12px; padding:10px 14px;
      border-radius:12px; border:1px solid var(--border); background:var(--accent); color:#081018;
      font-weight:600; cursor:pointer;
    }
    .btn:active { transform:translateY(1px); }
    .toast {
      position:fixed; right:16px; bottom:16px; padding:10px 12px; border-radius:12px; border:1px solid var(--border);
      background:color-mix(in hsl, var(--panel) 92%, transparent); box-shadow:0 6px 22px rgba(0,0,0,.25);
      font-size:13px; opacity:0; transform:translateY(10px); transition:all .3s ease; z-index:30;
    }
    .toast.show { opacity:1; transform:translateY(0); }
    a{ color:var(--accent); text-decoration:none; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="hud" id="hud">
    <div><strong>ARea Viewer ‚Äì Animation Fixed</strong></div>
    <div style="opacity:.8;margin-top:.35rem;font-size:12px">
      L√§dt <code>scene.json</code> + <code>scene.glb</code><br/>
      Unterst√ºtzt: <code>?scene=ID&base=URL</code><br/>
      Animation: <code>clip:"*"</code> = erster Clip
    </div>
  </div>

  <div class="tapgate" id="tapgate" role="dialog" aria-modal="true" aria-label="Zum Starten tippen">
    <div class="card">
      <h2 style="margin:0 0 8px 0">Tippen zum Starten</h2>
      <p style="margin:0 0 12px 0; color:var(--muted)">Die Animation startet per Klick (<code>start:"onClick"</code>).</p>
      <button class="btn" id="startBtn" type="button">‚ñ∂ Animation starten</button>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

    const qs = new URLSearchParams(location.search);
    
    // URL-Parameter: ?scene=ID&base=WORKER_ORIGIN
    const sceneId = qs.get('scene');
    const baseUrl = qs.get('base');
    
    // Scene JSON URL bestimmen
    let sceneJsonUrl;
    if (sceneId && baseUrl) {
      // Worker-Modus: https://worker.dev/scenes/ID/scene.json
      sceneJsonUrl = `${baseUrl}/scenes/${encodeURIComponent(sceneId)}/scene.json`;
      console.log('üì° Worker-Modus:', sceneJsonUrl);
    } else {
      // Fallback: lokale scene.json
      sceneJsonUrl = qs.get('src') || 'scene.json';
      console.log('üìÅ Lokaler Modus:', sceneJsonUrl);
    }

    const elApp = document.getElementById('app');
    const elTap = document.getElementById('tapgate');
    const elToast = document.getElementById('toast');

    const showToast = (msg) => {
      elToast.textContent = msg;
      elToast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>elToast.classList.remove('show'), 3500);
    };

    function resolveRelative(base, file) {
      try { 
        // Wenn file bereits absolute URL ist, direkt zur√ºckgeben
        if (/^https?:\/\//i.test(file)) return file;
        return new URL(file, base).toString(); 
      } catch { 
        return file; 
      }
    }

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    elApp.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(1.8, 1.4, 2.8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 1.0);
    const dir = new THREE.DirectionalLight(0xffffff, 1.5);
    dir.position.set(3, 5, 3);
    scene.add(hemi, dir);

    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(5, 64), 
      new THREE.MeshBasicMaterial({ color: 0x0f162b })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    let mixer = null;
    const actions = [];

    function normalizeAnimationConfig(data) {
      // KRITISCH: Editor sendet data.animation (Singular), nicht data.animations (Plural)
      const raw = data.animation || data.animations || {};
      
      // Wenn es ein Array ist (alter Viewer-Stil), nimm das erste Element
      const cfg = Array.isArray(raw) ? raw[0] : raw;
      
      return {
        enabled: cfg.enabled !== false,
        clipName: cfg.clipName || cfg.clip || '*',  // '*' = erster Clip
        loop: cfg.loop !== false,
        iterations: Math.max(1, Number(cfg.iterations) || 9999),
        start: (cfg.start === 'onClick' || cfg.start === 'onPlace') ? 'onClick' : 'onStart'
      };
    }

    function applyAnimation(gltf, animCfg) {
      if (!gltf.animations || gltf.animations.length === 0) {
        console.warn('‚ö†Ô∏è Keine Animationen im GLB gefunden');
        showToast('Keine Animationen vorhanden');
        return;
      }

      console.log('üé¨ GLB enth√§lt', gltf.animations.length, 'Clips:', gltf.animations.map(c=>c.name));
      
      mixer = new THREE.AnimationMixer(gltf.scene);

      let targetClip = null;
      const clipName = animCfg.clipName;

      if (clipName === '*' || clipName === null || clipName === '') {
        // Wildcard: nimm den ersten Clip
        targetClip = gltf.animations[0];
        console.log('üéØ Wildcard "*" ‚Üí erster Clip:', targetClip.name);
      } else {
        // Suche nach exaktem Namen
        targetClip = gltf.animations.find(c => c.name === clipName);
        if (!targetClip) {
          console.warn(`‚ùå Clip "${clipName}" nicht gefunden. Verf√ºgbar:`, gltf.animations.map(c=>c.name));
          console.log('üéØ Fallback ‚Üí erster Clip:', gltf.animations[0].name);
          targetClip = gltf.animations[0];
        } else {
          console.log('‚úÖ Clip gefunden:', clipName);
        }
      }

      if (!targetClip) {
        console.error('‚ùå Kein Clip zum Abspielen verf√ºgbar');
        return;
      }

      const action = mixer.clipAction(targetClip);
      
      if (animCfg.loop) {
        action.setLoop(THREE.LoopRepeat, animCfg.iterations);
        action.clampWhenFinished = false;
      } else {
        action.setLoop(THREE.LoopOnce, 0);
        action.clampWhenFinished = true;
      }

      action.reset();
      actions.push({ config: animCfg, action });

      console.log('‚úÖ Animation konfiguriert:', {
        clip: targetClip.name,
        loop: animCfg.loop,
        start: animCfg.start
      });

      if (animCfg.start === 'onStart') {
        action.play();
        showToast(`Animation l√§uft: ${targetClip.name}`);
        console.log('‚ñ∂Ô∏è Auto-Start');
      } else {
        showTapGate(true);
        console.log('‚è∏Ô∏è Wartet auf Klick');
      }
    }

    function showTapGate(show) { 
      document.getElementById('tapgate').classList.toggle('show', !!show); 
    }
    
    function startClickAnimations() {
      actions.forEach(({action}) => action.play());
      showTapGate(false);
      showToast('Animation gestartet');
      console.log('‚ñ∂Ô∏è Manueller Start durch Klick');
    }
    
    document.getElementById('tapgate').addEventListener('click', startClickAnimations);
    document.getElementById('startBtn').addEventListener('click', startClickAnimations);

    const loader = new GLTFLoader();
    loader.setCrossOrigin('anonymous');

    async function loadScene() {
      console.log('üì• Lade scene.json:', sceneJsonUrl);
      
      const res = await fetch(sceneJsonUrl, { 
        cache: 'no-cache',
        headers: { 'Accept': 'application/json' }
      });
      
      if (!res.ok) {
        throw new Error(`scene.json nicht gefunden (HTTP ${res.status})`);
      }
      
      const data = await res.json();
      console.log('üìÑ scene.json geladen:', data);

      // GLB URL bestimmen (mit Worker-Support)
      let glbUrl;
      if (sceneId && baseUrl) {
        // Worker: https://worker.dev/scenes/ID/scene.glb
        glbUrl = `${baseUrl}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;
      } else {
        // Relativ zur scene.json
        const glbPath = data.model?.url || data.model || data.src || data.glb || 'scene.glb';
        glbUrl = resolveRelative(sceneJsonUrl, glbPath);
      }

      console.log('üì¶ Lade GLB:', glbUrl);
      
      const animCfg = normalizeAnimationConfig(data);
      console.log('üé¨ Animation-Config:', animCfg);

      const gltf = await new Promise((resolve, reject) => {
        loader.load(
          glbUrl, 
          resolve, 
          (progress) => {
            if (progress.lengthComputable) {
              const pct = Math.round((progress.loaded / progress.total) * 100);
              console.log(`üì¶ GLB: ${pct}%`);
            }
          },
          reject
        );
      });

      console.log('‚úÖ GLB geladen, Animationen:', gltf.animations.length);

      // Model-Transform anwenden
      const modelCfg = data.model || {};
      if (modelCfg.scale) {
        gltf.scene.scale.setScalar(Number(modelCfg.scale) || 1);
      }
      if (modelCfg.rotateY) {
        gltf.scene.rotation.y = (Number(modelCfg.rotateY) || 0) * Math.PI / 180;
      }

      scene.add(gltf.scene);

      // Kamera zentrieren
      try {
        const box = new THREE.Box3().setFromObject(gltf.scene);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);
        
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const dist = Math.max(2.5, maxDim * 1.8);
        
        camera.position.set(
          center.x + dist * 0.7, 
          center.y + dist * 0.5, 
          center.z + dist * 0.7
        );
        camera.lookAt(center);
        controls.target.copy(center);
        controls.update();
        
        console.log('üì∑ Kamera zentriert auf:', center, 'Distanz:', dist);
      } catch (e) {
        console.warn('Kamera-Zentrierung fehlgeschlagen:', e);
      }

      applyAnimation(gltf, animCfg);
      showToast('Szene geladen');
    }

    const clock = new THREE.Clock();
    function tick() {
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    tick();
    
    loadScene().catch(err => { 
      console.error('‚ùå Fehler beim Laden:', err); 
      showToast(err.message || 'Fehler beim Laden'); 
    });
  </script>
</body>
</html>
