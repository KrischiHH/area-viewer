<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARea Viewer – WebXR Hit-Test (mit Animation)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui}
  #enter{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:12px;border:1px solid #555;background:#111;color:#fff}
  #msg{position:fixed;left:12px;bottom:12px;opacity:.9}
  #err{position:fixed;left:12px;top:12px;z-index:9;background:#b00020;color:#fff;padding:8px 10px;border-radius:8px;display:none;font:12px/1.35 monospace;max-width:min(92vw,680px);white-space:pre-wrap}
  #badge{position:fixed;right:12px;top:12px;z-index:9;background:#0b1220;color:#9cf;padding:6px 8px;border-radius:8px;font:12px system-ui}
  #hud{position:fixed;right:12px;bottom:12px;z-index:9;display:none;gap:8px;background:rgba(0,0,0,.4);border:1px solid rgba(255,255,255,.15);padding:6px;border-radius:12px;backdrop-filter:blur(6px)}
  #hud button{all:unset;cursor:pointer;color:#fff;padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:#111}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
  <div id="err"></div>
  <button id="enter">Start AR</button>
  <div id="msg">Android Chrome empfohlen · Tippe auf den Boden, um das Modell zu platzieren</div>
  <div id="badge">WEBXR BUILD</div>
  <div id="hud"><button id="btnPlay">Play/Pause</button></div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }  from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

let camera, scene, renderer, reticle, controller, hitTestSource=null, hitTestSourceRequested=false;
let model=null, mixer=null, clips=[];
const clock = new THREE.Clock();

const showErr = (m)=>{ const el=document.getElementById('err'); el.textContent=m; el.style.display='block'; console.error(m); };
const log = (...a)=>{ try{ console.log('[area-viewer]', ...a); }catch{} };

/* ========= Param-Normalisierung ========= */
const qs = new URLSearchParams(location.search);
const FORCE = (qs.get('force') || '').toLowerCase();
if (FORCE === 'webxr') {
  try { document.getElementById('badge').textContent = 'WEBXR (forced)'; } catch {}
}
let sceneParam = (qs.get('scene') || qs.get('src') || '').trim();
const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/, '');
const overrideGlb = (qs.get('glb') || '').trim();

const isHttp     = u => /^https?:\/\//i.test(u);
const isDataOrBlob = u => /^data:|^blob:/i.test(u);
const isGlbLike  = u => /\.(?:glb|gltf)(?:[?#]|$)/i.test(u);

let SCENE_GLB = '';
let SCENE_JSON = '';

if (overrideGlb) {
  SCENE_GLB = overrideGlb;
} else if (sceneParam) {
  if (isDataOrBlob(sceneParam)) {
    SCENE_JSON = sceneParam;
  } else if (isHttp(sceneParam)) {
    if (isGlbLike(sceneParam)) SCENE_GLB = sceneParam;
    else SCENE_JSON = sceneParam;
  } else {
    const id = sceneParam.replace(/\/+$/,'');
    SCENE_GLB  = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.glb`;
    SCENE_JSON = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.json`;
  }
}

/* ===== Viewer-Konfig (inkl. Animation) ===== */
const cfg = {
  modelUrl: SCENE_GLB || 'https://modelviewer.dev/shared-assets/models/Astronaut.glb',
  position: [0,0,0],
  rotation: [0,0,0],  // Grad
  scale:[0.6,0.6,0.6],
  // Animation (Editor-kompatibel)
  animationName: '*',           // '*' | 'none' | Clipname
  animLoop: true,               // true/false
  animIterations: 9999,         // Wiederholungen bei LoopRepeat
  animStart: 'onPlace'          // onPlace | onStart | onClick
};

// ---------- Utils ----------
const rad2deg = r => (r||0) * 180/Math.PI;
const deg2rad = d => (d||0) * Math.PI/180;

// ---------- Szene aus externer JSON (optional) ----------
async function loadScene(){
  if (SCENE_GLB) { cfg.modelUrl = SCENE_GLB; return; }
  if (!SCENE_JSON) return;

  try{
    const r = await fetch(SCENE_JSON, {cache:'no-cache', mode:'cors'});
    if(!r.ok) throw new Error('scene.json Load '+r.status+' '+r.statusText);
    const j = await r.json();

    const resolveAgainstJson = (u)=>{
      if (!u) return u;
      if (isHttp(u) || isDataOrBlob(u)) return u;
      try { return new URL(u, SCENE_JSON).href; } catch { return u; }
    };

    // Model
    if (j?.model?.url)                cfg.modelUrl = resolveAgainstJson(j.model.url);
    if (Array.isArray(j?.model?.position)) cfg.position = j.model.position;
    if (Array.isArray(j?.model?.rotationDeg)) cfg.rotation = j.model.rotationDeg;
    else if (Array.isArray(j?.model?.rotation)) cfg.rotation = j.model.rotation;
    if (Array.isArray(j?.model?.scale)) cfg.scale = j.model.scale;
    else if (typeof j?.model?.scale === 'number') cfg.scale = [j.model.scale, j.model.scale, j.model.scale];

    // Animation – legacy
    if (j?.model?.animation != null) {
      cfg.animationName = (j.model.animation === '' ? '*' : j.model.animation);
    }
    // Neues Schema (Editor)
    if (j?.animation) {
      const a = j.animation;
      if (a.clipName != null) cfg.animationName = (a.clipName === '' ? '*' : a.clipName);
      if (a.loop != null)     cfg.animLoop = !!a.loop;
      if (a.repeats != null)  cfg.animIterations = Math.max(0, parseInt(a.repeats,10)||0) || 9999;
      if (a.start)            cfg.animStart = String(a.start).toLowerCase(); // onstart/onplace/onclick
    }

    log('Scene animation cfg', {
      animationName: cfg.animationName,
      animLoop: cfg.animLoop,
      animIterations: cfg.animIterations,
      animStart: cfg.animStart
    });
  }catch(e){
    console.warn(e);
    showErr('scene.json konnte nicht geladen werden:\n'+e.message);
  }
}

// -------- Fallbacks aus Query --------
function applyQueryFallback(){
  const glb = qs.get('glb');
  if (glb) cfg.modelUrl = glb;

  const rx = qs.get('rx'), ry = qs.get('ry'), rz = qs.get('rz');
  if (rx!=null || ry!=null || rz!=null){
    cfg.rotation = [rad2deg(parseFloat(rx)), rad2deg(parseFloat(ry)), rad2deg(parseFloat(rz))].map(v=>isFinite(v)?v:0);
  }

  const px = parseFloat(qs.get('px')), py = parseFloat(qs.get('py')), pz = parseFloat(qs.get('pz'));
  if ([px,py,pz].some(v=>!isNaN(v))) cfg.position = [px||0, py||0, pz||0];

  const sx = parseFloat(qs.get('sx')), sy = parseFloat(qs.get('sy')), sz = parseFloat(qs.get('sz'));
  if ([sx,sy,sz].some(v=>!isNaN(v))) cfg.scale = [sx||1, sy||1, sz||1];

  const an = (qs.get('anim') || '').trim();
  if (an) cfg.animationName = an;
}

// ---------- THREE Init ----------
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(0,6,0); scene.add(dir);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // Reticle
  const ring = new THREE.RingGeometry(0.07, 0.08, 32).rotateX(-Math.PI/2);
  const mat = new THREE.MeshBasicMaterial({color:0x66ccff});
  reticle = new THREE.Mesh(ring, mat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  addEventListener('resize', ()=>{
  // Während XR presenting NICHT setSize aufrufen – das macht Three im XR-Loop selbst
  if (!renderer.xr.isPresenting) {
    renderer.setSize(innerWidth, innerHeight);
  }
});
  document.getElementById('enter').addEventListener('click', startAR);
}

// ---------- Animation helpers ----------
function startSelectedClip(){
  if (!mixer || !clips.length) return;
  const sel = (cfg.animationName ?? '*');
  if (sel === 'none') { log('Animation: none'); return; }

  // Clip wählen
  const clip = (sel === '*') ? clips[0] : (clips.find(c=>c.name===sel) || clips[0]);
  if (!clip) { log('Keine Clips im GLB'); return; }

  mixer.stopAllAction();
  const act = mixer.clipAction(clip);
  if (cfg.animLoop){
    act.setLoop(THREE.LoopRepeat, cfg.animIterations || 9999);
  } else {
    act.setLoop(THREE.LoopOnce, 0);
    act.clampWhenFinished = true;
  }
  act.reset().play();
  mixer.timeScale = 1;
  log('Animation gestartet', { name: clip.name, loop: cfg.animLoop, iters: cfg.animIterations });
}

function ensureHudForOnClick(){
  if (cfg.animStart !== 'onclick') return;
  const hud = document.getElementById('hud');
  const btn = document.getElementById('btnPlay');
  hud.style.display = 'flex';
  btn.onclick = ()=>{
    if (!mixer) return;
    // Beim ersten Klick ggf. den Clip initial starten
    if (mixer.timeScale == null || (mixer._startedOnce!==true && clips.length)){
      startSelectedClip();
      mixer._startedOnce = true;
      return;
    }
    // Danach togglen
    mixer.timeScale = (mixer.timeScale === 0) ? 1 : 0;
  };
}

/* ---------- GLB/GLTF Loader ---------- */
async function loadGLTFFlexible(url) {
  const res = await fetch(url, { mode: 'cors', credentials: 'omit' });
  if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

  const ct = (res.headers.get('content-type') || '').toLowerCase();
  const looksGLB = /\.glb(?:[?#]|$)/i.test(url) || ct.includes('model/gltf-binary') || ct.includes('application/octet-stream');

  const loader = new GLTFLoader();
  loader.setCrossOrigin('anonymous');
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(draco);

  if (looksGLB) {
    const buf = await res.arrayBuffer();
    return new Promise((resolve, reject)=>
      loader.parse(buf, '', gltf=>resolve(gltf), err=>reject(err))
    );
  } else {
    const text = await res.text();
    let json;
    try { json = JSON.parse(text); }
    catch (e) { showErr('GLTF-JSON konnte nicht geparst werden.'); throw e; }
    const base = url.replace(/[^\/?#]*([?#].*)?$/, '');
    return new Promise((resolve, reject)=>
      loader.parse(json, base, gltf=>resolve(gltf), err=>reject(err))
    );
  }
}

/* ---------- Tap: platzieren & laden ---------- */
async function onSelect() {
  if (!reticle.visible) return;

  if (!model) {
    try {
      const gltf = await loadGLTFFlexible(cfg.modelUrl);
      model = gltf.scene;
      const [sx,sy,sz] = cfg.scale;    model.scale.set(sx,sy,sz);
      const [rx,ry,rz] = cfg.rotation; model.rotation.set(deg2rad(rx), deg2rad(ry), deg2rad(rz));
      model.position.setFromMatrixPosition(reticle.matrix);
      scene.add(model);

      clips = gltf.animations || [];
      log('GLB Clips', clips.map(c=>({name:c.name,dur:c.duration.toFixed(2)})));
      if (clips.length) {
        mixer = new THREE.AnimationMixer(model);
        // Autostart: onPlace oder onStart → direkt nach Platzierung starten
        if (cfg.animStart === 'onplace' || cfg.animStart === 'onstart') {
          startSelectedClip();
        } else if (cfg.animStart === 'onclick') {
          ensureHudForOnClick();
        }
      } else {
        log('Keine Animationen im Modell gefunden.');
      }
    } catch (err) {
      console.error('GLTF load failed', err);
      showErr('Fehler beim Laden des Objekts:\n' + (err?.message || err || 'Unbekannt'));
    }
  } else {
    model.position.setFromMatrixPosition(reticle.matrix);
  }
}

// ---------- WebXR ----------
async function startAR(){
  if (!navigator.xr) { showErr('WebXR nicht verfügbar.'); return; }
  const isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
  if (!isARSupported) { showErr('Dein Gerät/Browser unterstützt kein WebXR-AR.'); return; }

  const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test','local-floor'] });
  renderer.xr.setReferenceSpaceType('local-floor');
  await renderer.xr.setSession(session);
  document.getElementById('enter').style.display='none';
  animate();
}

function animate() { renderer.setAnimationLoop(render); }

function render(t, frame) {
  const dt = clock.getDelta(); if (mixer) mixer.update(dt);
  if (!frame){ renderer.render(scene, camera); return; }
  const referenceSpace = renderer.xr.getReferenceSpace();
  const session = renderer.xr.getSession();

  if (!hitTestSourceRequested) {
    session.requestReferenceSpace('viewer').then((viewerSpace) => {
      session.requestHitTestSource({ space: viewerSpace }).then((source) => { hitTestSource = source; });
    });
    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
    hitTestSourceRequested = true;
  }

  if (hitTestSource) {
    const results = frame.getHitTestResults(hitTestSource);
    if (results.length) {
      const hit = results[0];
      const pose = hit.getPose(referenceSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else { reticle.visible = false; }
  }

  renderer.render(scene, camera);
}

// ---------- Boot ----------
(async ()=>{
  try{ await loadScene(); }catch(e){ console.warn(e); }
  applyQueryFallback();
  init();
})();
</script>
</body>
</html>
