<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>ARea Viewer – Surface AR (WebXR)</title>

  <style>
    :root{color-scheme:dark light}
    *,*::before,*::after{box-sizing:border-box}
    html,body{
      margin:0;
      height:100%;
      background:#000;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif
    }
    body{
      position:relative;
      overflow:hidden;
    }
    canvas#xr-canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100svh;
      display:block;
      touch-action:none;
    }
    #poster{
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background:#05070c;
      color:#fff;
      text-align:center;
      padding:24px;
      gap:16px;
      z-index:5;
    }
    #poster-inner{
      max-width:420px;
      padding:24px 20px;
      border-radius:24px;
      background:radial-gradient(circle at top,#243b74,#05070c);
      box-shadow:0 18px 40px rgba(0,0,0,0.6);
      border:1px solid rgba(255,255,255,0.12);
    }
    #poster h1{
      font-size:22px;
      margin:0 0 8px;
    }
    #poster p{
      margin:0 0 16px;
      font-size:14px;
      opacity:0.9;
    }
    #startAr{
      appearance:none;
      border:none;
      border-radius:999px;
      padding:10px 20px;
      font-size:15px;
      font-weight:500;
      background:linear-gradient(135deg,#5ddcff,#3c67e3);
      color:#fff;
      cursor:pointer;
      box-shadow:0 10px 25px rgba(0,0,0,0.5);
    }
    #startAr[disabled]{
      opacity:0.6;
      cursor:wait;
    }
    #hud{
      position:fixed;
      right:max(12px,env(safe-area-inset-right));
      bottom:max(12px,env(safe-area-inset-bottom));
      display:flex;
      gap:8px;
      z-index:4;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.18);
      padding:6px 8px;
      border-radius:999px;
      backdrop-filter:blur(8px);
      align-items:center;
    }
    #hud.hidden{display:none}
    #hud button{
      all:unset;
      cursor:pointer;
      padding:6px 10px;
      border-radius:999px;
      color:#fff;
      user-select:none;
      font-size:13px;
      border:1px solid transparent;
    }
    #hud button.primary{
      border-color:rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.35);
    }
    #status{
      font-size:11px;
      color:#ddd;
      max-width:140px;
      text-align:right;
    }
    #err{
      position:fixed;
      left:12px;
      top:12px;
      z-index:9;
      background:#b00020;
      color:#fff;
      padding:8px 10px;
      border-radius:8px;
      display:none;
      font:12px/1.35 monospace;
      max-width:min(92vw,680px);
      white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <div id="err"></div>

  <!-- Begrüßungsposter (statt Preview) -->
  <div id="poster">
    <div id="poster-inner">
      <h1>ARea AR-Erlebnis</h1>
      <p>Tippe auf „AR starten“, richte dein Gerät auf eine ebene Fläche und platziere dann das 3D-Modell.</p>
      <button id="startAr">AR starten</button>
    </div>
  </div>

  <!-- WebGL-Canvas für WebXR -->
  <canvas id="xr-canvas"></canvas>

  <!-- Simple HUD für Status & Play/Pause -->
  <div id="hud" class="hidden">
    <div id="status">Suche nach Oberfläche…</div>
    <button id="btnPlay" class="primary" title="Animation starten/pausieren">▶︎</button>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

    const qs = new URLSearchParams(location.search);
    const devParam = qs.get('dev');
    const DEV = qs.has('dev') && (devParam === null || devParam === '' || devParam === '1' || devParam === 'true');

    function bust(u){
      if (!DEV || !u) return u;
      const sep = u.includes('?') ? '&' : '?';
      return u + sep + 'v=' + Date.now();
    }

    // ---------- URL / Szenen-Config wie im Native-Viewer ----------
    let sceneId   = (qs.get('scene') || qs.get('src') || '').trim();
    const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/, '');
    const overrideGlb  = (qs.get('glb')  || '').trim();

    const isHttp = (u)=> /^https?:\/\//i.test(u);
    const isDataOrBlob = (u)=> u.startsWith('data:') || u.startsWith('blob:');
    const endsWithAny = (u,exts)=> exts.some(ext=> u.toLowerCase().endsWith(ext));

    let SCENE_GLB  = '';
    let SCENE_JSON = '';

    if (overrideGlb){
      SCENE_GLB = overrideGlb;
    }

    if (sceneId) {
      if (isDataOrBlob(sceneId)) {
        SCENE_JSON = sceneId;
      } else if (isHttp(sceneId)) {
        if (endsWithAny(sceneId, ['.glb','.gltf'])) {
          if (!SCENE_GLB) SCENE_GLB = sceneId;
        } else {
          SCENE_JSON = sceneId;
        }
      } else {
        const id = sceneId.replace(/\/+$/,'');
        if (!SCENE_GLB) {
          SCENE_GLB = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.glb`;
        }
        SCENE_JSON = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.json`;
      }
    }

    const errBox   = document.getElementById('err');
    const poster   = document.getElementById('poster');
    const startBtn = document.getElementById('startAr');
    const hud      = document.getElementById('hud');
    const statusEl = document.getElementById('status');
    const btnPlay  = document.getElementById('btnPlay');
    const canvas   = document.getElementById('xr-canvas');

    function setError(msg){
      errBox.textContent = msg;
      errBox.style.display = 'block';
      console.error('[area-webxr]', msg);
    }
    function setStatus(msg){
      statusEl.textContent = msg;
    }

    // ---------- three.js Grundsetup ----------
    const renderer = new THREE.WebGLRenderer({
      canvas,
      alpha:true,
      antialias:true
    });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;

    const scene3d = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      70,
      window.innerWidth / window.innerHeight,
      0.01,
      20
    );
    scene3d.add(camera);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444455, 1.0);
    scene3d.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1,2,1);
    scene3d.add(dir);

    const reticleGeom = new THREE.RingGeometry(0.08, 0.1, 32);
    reticleGeom.rotateX(-Math.PI/2);
    const reticleMat  = new THREE.MeshBasicMaterial({ color:0x00ffff, opacity:0.8, transparent:true });
    const reticle = new THREE.Mesh(reticleGeom, reticleMat);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene3d.add(reticle);

    // ---------- GLB / Animation-Setup ----------
    const cfg = {
      model:{ url: SCENE_GLB || '', animation:'*' },
      animation:{ start:'onStart' } // onStart | onPlace | manual | onClick (wir nutzen onStart/onPlace)
    };

    let gltfScene   = null;
    let mixer       = null;
    let clips       = [];
    let activeAction = null;
    let isPlaying   = false;
    let startMode   = 'onStart';

    const clock = new THREE.Clock();

    async function loadConfigAndModel(){
      try {
        // scene.json laden (falls vorhanden)
        if (SCENE_JSON && !isDataOrBlob(SCENE_JSON)) {
          const r = await fetch(bust(SCENE_JSON), { cache:'no-cache' });
          if (!r.ok) throw new Error('scene.json: ' + r.status + ' ' + r.statusText);
          const j = await r.json();

          if (j.model){
            if (j.model.url) cfg.model.url = j.model.url;
            if (j.model.animation) cfg.model.animation = j.model.animation;
          }
          if (j.animation){
            if (j.animation.clipName) cfg.model.animation = j.animation.clipName;
            if (j.animation.start)    cfg.animation.start = j.animation.start;
          }
        }

        const glbUrl = bust(cfg.model.url || SCENE_GLB);
        if (!glbUrl) throw new Error('Kein GLB-URL gefunden');

        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync(glbUrl);
        gltfScene = gltf.scene;
        scene3d.add(gltfScene);

        clips = gltf.animations || [];
        if (clips.length > 0){
          mixer = new THREE.AnimationMixer(gltfScene);

          // Clip-Auswahl
          let chosenClip = clips[0];
          const sel = cfg.model.animation;
          if (typeof sel === 'string' && sel && sel !== '*') {
            const byName = clips.find(c => c.name === sel);
            if (byName) chosenClip = byName;
          } else if (Number.isFinite(sel)) {
            const idx = Math.max(0, Math.min(clips.length-1, sel|0));
            chosenClip = clips[idx];
          }

          activeAction = mixer.clipAction(chosenClip);
          activeAction.clampWhenFinished = false;
          activeAction.loop = THREE.LoopRepeat;

          startMode = String(cfg.animation.start || 'onStart').toLowerCase();
          console.log('[area-webxr] clips:', clips.map(c => c.name), 'chosen:', chosenClip.name, 'startMode:', startMode);

          if (startMode === 'onstart') {
            activeAction.play();
            isPlaying = true;
            btnPlay.textContent = '⏸';
          } else {
            // onPlace / manual / onClick → zunächst „bewusst“ pausiert
            activeAction.play();
            activeAction.paused = true;
            isPlaying = false;
            btnPlay.textContent = '▶︎';
          }
        } else {
          startMode = 'none';
          btnPlay.style.display = 'none';
        }

      } catch(e){
        setError('Modell konnte nicht geladen werden: ' + e.message);
        console.error(e);
      }
    }

    loadConfigAndModel();

    // ---------- WebXR Hit-Test ----------
    let xrSession = null;
    let hitTestSource = null;
    let referenceSpace = null;

    async function startWebXR(){
      if (!('xr' in navigator)) {
        fallbackToNative();
        return;
      }
      let supported = false;
      try{
        supported = await navigator.xr.isSessionSupported('immersive-ar');
      }catch(e){
        supported = false;
      }
      if (!supported){
        fallbackToNative();
        return;
      }

      try {
        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures:['hit-test','local-floor']
        });
        xrSession = session;

        renderer.xr.setReferenceSpaceType('local-floor');
        await renderer.xr.setSession(session);

        let viewerSpace = await session.requestReferenceSpace('viewer');
        try {
          referenceSpace = await session.requestReferenceSpace('local-floor');
        } catch {
          referenceSpace = await session.requestReferenceSpace('local');
        }
        hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

        session.addEventListener('end', ()=>{
          hitTestSource = null;
          referenceSpace = null;
          xrSession = null;
          reticle.visible = false;
          isPlaying = false;
          if (activeAction){
            activeAction.paused = true;
            activeAction.reset();
          }
          setStatus('Session beendet');
          hud.classList.add('hidden');
          poster.style.display = 'flex';
          renderer.setAnimationLoop(null);
        });

        poster.style.display = 'none';
        hud.classList.remove('hidden');
        setStatus('Bewege dein Gerät, um eine Fläche zu finden');

        renderer.setAnimationLoop((time, frame)=>{
          const dt = clock.getDelta();
          if (mixer && isPlaying) mixer.update(dt);

          if (frame && hitTestSource && referenceSpace) {
            const hits = frame.getHitTestResults(hitTestSource);
            if (hits.length > 0) {
              const pose = hits[0].getPose(referenceSpace);
              if (pose) {
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
                setStatus('Tippe, um das Modell zu platzieren');
              }
            } else {
              reticle.visible = false;
              setStatus('Suche nach Oberfläche…');
            }
          }

          renderer.render(scene3d, camera);
        });

      } catch(e){
        setError('WebXR-Session konnte nicht gestartet werden: ' + e.message);
        console.error(e);
        fallbackToNative();
      }
    }

    function fallbackToNative(){
      // iOS / kein WebXR → auf native Viewer (area-viewer.html) umleiten
      const url = new URL(window.location.href);
      url.pathname = url.pathname.replace(/webxr\.html$/, 'area-viewer.html');
      window.location.href = url.toString();
    }

    startBtn.addEventListener('click', ()=>{
      startBtn.disabled = true;
      startWebXR();
    });

    // ---------- Platzierung & Animation-Logik ----------
    let modelPlaced = false;

    renderer.domElement.addEventListener('click', ()=>{
      if (!xrSession) return;            // Nicht in AR
      if (!gltfScene) return;           // Modell noch nicht da
      if (!reticle.visible) return;     // Keine Oberfläche

      // Modell an Reticle-Position setzen
      reticle.matrix.decompose(
        gltfScene.position,
        gltfScene.quaternion,
        gltfScene.scale
      );
      modelPlaced = true;

      if (activeAction){
        if (startMode === 'onplace') {
          // Spezifik: erster Place → starten, Re-Place → toggeln
          if (!isPlaying) {
            activeAction.paused = false;
            activeAction.reset();
            isPlaying = true;
            btnPlay.textContent = '⏸';
          } else {
            // erneutes Platzieren → pausieren (du kannst das Verhalten hier anpassen)
            activeAction.paused = true;
            isPlaying = false;
            btnPlay.textContent = '▶︎';
          }
        }
      }
    });

    // Play/Pause-Button (funktioniert in Preview + AR)
    btnPlay.addEventListener('click', ()=>{
      if (!activeAction) return;
      if (!modelPlaced && startMode === 'onplace') {
        // Hinweis: bei onPlace in AR macht Play ohne Placement wenig Sinn,
        // aber im Editor-Preview oder Debug trotzdem möglich.
      }
      if (!isPlaying) {
        activeAction.paused = false;
        isPlaying = true;
        btnPlay.textContent = '⏸';
      } else {
        activeAction.paused = true;
        isPlaying = false;
        btnPlay.textContent = '▶︎';
      }
    });

    // ---------- Resize ----------
    window.addEventListener('resize', ()=>{
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  </script>
</body>
</html>
