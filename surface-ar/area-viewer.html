<!doctype html>
<html lang="de" class="theme-slate">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ARea Viewer â€“ Drop-in (Animation Fix)</title>
  <style>
    :root { color-scheme: dark; }
    :root.theme-slate{
      --bg:#0b1020; --panel:#10172a; --text:#e6edf3; --muted:#94a3b8; --accent:#5b9dff; --border:#20304b;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #app { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }
    .hud {
      position:fixed; inset:16px auto auto 16px; padding:10px 12px;
      background:color-mix(in hsl, var(--panel) 88%, transparent);
      border:1px solid var(--border); border-radius:12px; backdrop-filter: blur(8px);
      box-shadow: 0 6px 24px rgba(0,0,0,.25); font-size:14px; user-select:none;
    }
    .hud code{ padding:.15em .4em; background:#0006; border:1px solid #ffffff1a; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tapgate {
      position:fixed; inset:0; display:none; place-items:center; z-index:20;
      background:linear-gradient(180deg, rgba(7,12,24,.75), rgba(7,12,24,.85));
      color:var(--text);
    }
    .tapgate.show { display:grid; }
    .card {
      width:min(520px, 92vw); padding:20px; border-radius:16px; border:1px solid var(--border);
      background:color-mix(in hsl, var(--panel) 92%, transparent);
      box-shadow: 0 10px 30px rgba(0,0,0,.35); text-align:center;
    }
    .btn {
      display:inline-flex; align-items:center; gap:.5rem; margin-top:12px; padding:10px 14px;
      border-radius:12px; border:1px solid var(--border); background:var(--accent); color:#081018;
      font-weight:600; cursor:pointer;
    }
    .btn:active { transform:translateY(1px); }
    .toast {
      position:fixed; right:16px; bottom:16px; padding:10px 12px; border-radius:12px; border:1px solid var(--border);
      background:color-mix(in hsl, var(--panel) 92%, transparent); box-shadow:0 6px 22px rgba(0,0,0,.25);
      font-size:13px; opacity:0; transform:translateY(10px); transition:all .3s ease; z-index:30;
    }
    .toast.show { opacity:1; transform:translateY(0); }
    a{ color:var(--accent); text-decoration:none; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="hud" id="hud">
    <div><strong>ARea Viewer â€“ Animation Fix</strong></div>
    <div style="opacity:.8;margin-top:.35rem">
      LÃ¤dt <code>scene.json</code> (oder <code>?scene=â€¦</code>) und <code>scene.glb</code>.<br/>
      Animationen per <code>onStart</code>/<code>onClick</code>. Fallback: <em>alle Clips</em> abspielen.
    </div>
  </div>

  <div class="tapgate" id="tapgate" role="dialog" aria-modal="true" aria-label="Zum Starten tippen">
    <div class="card">
      <h2 style="margin:0 0 8px 0">Tippen zum Starten</h2>
      <p style="margin:0 0 12px 0; color:var(--muted)">Deine Szene wartet auf einen Nutzer-Klick (<code>start:"onClick"</code>).</p>
      <button class="btn" id="startBtn" type="button">â–¶ Animation starten</button>
      <div style="margin-top:10px; font-size:12px; color:var(--muted)">Falls nichts passiert: PrÃ¼fe Clip-Namen in <code>scene.json</code>.</div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

    const qs = new URLSearchParams(location.search);
    const sceneJsonUrl = qs.get('scene') || 'scene.json';

    const elApp = document.getElementById('app');
    const elTap = document.getElementById('tapgate');
    const elStart = document.getElementById('startBtn');
    const elToast = document.getElementById('toast');

    const showToast = (msg) => {
      elToast.textContent = msg;
      elToast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>elToast.classList.remove('show'), 3000);
    };

    function normalizeAnimation(a = {}) {
      const out = { ...a };
      out.enabled = a.enabled !== false;
      out.loop = !!a.loop;
      out.iterations = out.loop ? Math.max(1, Number(a.iterations) || 9999) : 1;
      out.start = (a.start === 'onClick') ? 'onClick' : 'onStart';
      if (typeof out.clip !== 'string') out.clip = null;
      return out;
    }

    function resolveRelative(baseUrl, file) {
      try { return new URL(file, baseUrl).toString(); } catch { return file; }
    }

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    elApp.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(1.8, 1.4, 2.8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.8);
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 5, 3);
    scene.add(hemi, dir);

    const ground = new THREE.Mesh(new THREE.CircleGeometry(5, 64), new THREE.MeshBasicMaterial({ color: 0x0f162b }));
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    let mixer = null;
    const actions = [];

    function applyAnimation(glb, metaList) {
      if (!glb.animations || glb.animations.length === 0) {
        showToast('Keine Clips im GLB gefunden.');
        console.warn('âš ï¸ Keine GLB-Animationen vorhanden.');
        return;
      }
      mixer = new THREE.AnimationMixer(glb.scene);

      const byName = new Map(glb.animations.map(c => [c.name, c]));
      const explicit = metaList.map(normalizeAnimation).filter(m => m.enabled && m.clip);
      const anyClick = (list) => list.some(m => m.start === 'onClick');
      const anyAuto  = (list) => list.some(m => m.start === 'onStart');

      if (explicit.length) {
        console.log('ðŸŽ¬ Explizite Clips aus scene.json:', explicit.map(m=>m.clip));
        explicit.forEach(meta => {
          const clip = byName.get(meta.clip);
          if (!clip) { console.warn('âŒ Clip nicht gefunden:', meta.clip); return; }
          const act = mixer.clipAction(clip);
          if (meta.loop) { act.setLoop(THREE.LoopRepeat, meta.iterations); act.clampWhenFinished = false; }
          else { act.setLoop(THREE.LoopOnce, 0); act.clampWhenFinished = true; }
          act.enabled = true; act.reset();
          actions.push({ meta, action: act });
        });
      } else {
        // Fallback: ALLE Clips spielen
        const base = normalizeAnimation(metaList[0] || { loop:true, iterations:9999, start:'onStart' });
        console.log(`ðŸŽ¯ Keine spezifischen Clips â†’ Fallback: ALLE ${glb.animations.length} Clips`, base);
        glb.animations.forEach(clip => {
          const meta = { ...base, clip: clip.name };
          const act = mixer.clipAction(clip);
          if (meta.loop) { act.setLoop(THREE.LoopRepeat, meta.iterations); act.clampWhenFinished = false; }
          else { act.setLoop(THREE.LoopOnce, 0); act.clampWhenFinished = true; }
          act.enabled = true; act.reset();
          actions.push({ meta, action: act });
        });
      }

      const hasClick = anyClick(actions.map(a=>a.meta));
      const hasAuto  = anyAuto(actions.map(a=>a.meta));
      console.log(`âœ… Actions vorbereitet: ${actions.length} | onStart=${hasAuto} | onClick=${hasClick}`);

      if (hasAuto) actions.forEach(({meta, action}) => { if (meta.start === 'onStart') action.play(); });
      if (hasClick) showTapGate(true);

      showToast(`${actions.length} Animation(en) bereit`);
    }

    function showTapGate(show) { document.getElementById('tapgate').classList.toggle('show', !!show); }
    function startClickAnimations() {
      actions.forEach(({meta, action}) => { if (meta.start === 'onClick') action.play(); });
      showTapGate(false);
      showToast('Animation gestartet.');
    }
    document.getElementById('tapgate').addEventListener('click', startClickAnimations);
    document.getElementById('startBtn').addEventListener('click', startClickAnimations);

    const loader = new GLTFLoader();
    loader.setCrossOrigin('anonymous');

    async function loadScene() {
      const res = await fetch(sceneJsonUrl, { cache:'no-cache' });
      if (!res.ok) throw new Error(`scene.json nicht gefunden (${res.status})`);
      const data = await res.json();
      console.log('ðŸ“„ scene.json:', data);

      const glbPath = data.model || data.src || data.glb || 'scene.glb';
      const glbUrl = resolveRelative(sceneJsonUrl, glbPath);

      const animationsMeta = Array.isArray(data.animations) ? data.animations : [{ clip:null, loop:true, iterations:9999, enabled:true, start:'onStart' }];
      console.log('ðŸŽ¬ Anim-Meta:', animationsMeta);

      const gltf = await new Promise((resolve, reject) => loader.load(glbUrl, resolve, undefined, reject));
      console.log('ðŸ“¦ GLB Clips:', gltf.animations.map(c=>c.name));

      if (data.modelTransform && typeof data.modelTransform === 'object') {
        const t = data.modelTransform;
        gltf.scene.position.set(t.x || 0, t.y || 0, t.z || 0);
        gltf.scene.rotation.set((t.rx||0)*Math.PI/180, (t.ry||0)*Math.PI/180, (t.rz||0)*Math.PI/180);
        if (t.s) gltf.scene.scale.setScalar(t.s);
      }

      scene.add(gltf.scene);

      try {
        const box = new THREE.Box3().setFromObject(gltf.scene);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        const dist = Math.max(2.2, maxDim * 1.6);
        camera.position.set(center.x + dist, center.y + dist * 0.6, center.z + dist);
        camera.lookAt(center);
        controls.target.copy(center);
        controls.update();
      } catch {}

      applyAnimation(gltf, animationsMeta);
      showToast('Szene geladen.');
    }

    const clock = new THREE.Clock();
    function tick() {
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    tick();
    loadScene().catch(err => { console.error(err); showToast(err.message || 'Fehler beim Laden.'); });
  </script>
</body>
</html>
