<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>ARea – AR Viewer (Animation)</title>
  <style>
    :root{ color-scheme:dark }
    html,body{ margin:0; height:100%; background:#000; color:#e9eefb; font:14px/1.45 system-ui,Segoe UI,Inter,Roboto,Arial }
    canvas{ display:block }
    #hud{ position:fixed; left:12px; bottom:12px; display:flex; gap:8px; z-index:5;
          background: color-mix(in srgb, #0f1626 88%, transparent);
          border:1px solid #22314d; padding:6px; border-radius:12px; backdrop-filter: blur(6px); }
    #hud button{ all:unset; cursor:pointer; color:#fff; padding:8px 12px; border-radius:10px; border:1px solid #22314d; background:#0f1626 }
    #hud button:hover{ border-color:#6ea8ff }
    #badge{ position:fixed; right:12px; top:12px; z-index:8; background:#0b1220; color:#9cf; padding:6px 8px; border-radius:8px; font:12px system-ui }
    #err{ position:fixed; left:12px; top:12px; z-index:9; background:#b00020; color:#fff; padding:8px 10px; border-radius:8px; display:none;
          font:12px/1.35 monospace; max-width:min(92vw,680px); white-space:pre-wrap }
    #enter{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:6;
            padding:12px 18px; border-radius:12px; border:1px solid #22314d; background:#0f1626; color:#fff; }
    #native{ position:fixed; left:12px; top:12px; z-index:7; padding:8px 12px; border-radius:10px; border:1px solid #22314d; background:#0f1626; color:#fff; display:none }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="err"></div>
  <button id="enter">AR starten</button>
  <button id="native">In AR (nativ) öffnen</button>
  <div id="badge">AR‑Animation</div>
  <div id="hud" style="display:none">
    <button id="btnRepose">Neu platzieren</button>
    <button id="btnPlay" style="display:none">Play/Pause</button>
    <button id="btnMute" style="display:none">Ton</button>
  </div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }  from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

const qs = new URLSearchParams(location.search);
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);

const showErr = (m)=>{ const el=document.getElementById('err'); el.textContent=m; el.style.display='block'; console.error(m); };

function resolveRel(u, base){
  if (!u) return '';
  if (/^https?:|^data:|^blob:/.test(u)) return u;
  try { return new URL(u, base).href; } catch { return u; }
}

// -------- Config laden (scene/base oder src) ----------
async function loadConfig(){
  const src = qs.get('src');
  if (src){
    if (src.startsWith('data:')){
      const after = src.split(',')[1] || '';
      if (src.includes(';base64,')){
        const bin = atob(after);
        const bytes = Uint8Array.from(bin, c => c.charCodeAt(0));
        const text = new TextDecoder('utf-8').decode(bytes);
        return JSON.parse(text);
      } else {
        return JSON.parse(decodeURIComponent(after));
      }
    } else if (/^https?:\/\//.test(src)){
      const r = await fetch(src, { cache:'no-store' });
      if (!r.ok) throw new Error('src-URL nicht erreichbar');
      const j = await r.json();
      try{
        const u = new URL(src, location.href);
        if (u.pathname.endsWith('/scene.json')){
          j.__base = u.origin + u.pathname.replace(/\/scene\.json$/, '');
        }
      }catch{}
      return j;
    } else {
      return JSON.parse(decodeURIComponent(src));
    }
  }
  const id   = qs.get('scene') || qs.get('id');
  const base = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/,'');
  if (!id) throw new Error('Kein scene oder src angegeben');
  const root = `${base}/scenes/${encodeURIComponent(id)}`;
  const r = await fetch(`${root}/scene.json`, { cache:'no-store' });
  if (!r.ok) throw new Error('scene.json nicht gefunden');
  const j = await r.json();
  j.__base = root;
  return j;
}

function normalizeCfg(cfg){
  cfg.model = cfg.model || {};
  cfg.audio = cfg.audio || {};
  cfg.meta  = cfg.meta  || {};
  cfg.animation = cfg.animation || {};

  // Legacy → neue Felder
  if (cfg.audio.src && !cfg.audio.url) cfg.audio.url = cfg.audio.src;
  if (cfg.audio.autoplay == null) cfg.audio.autoplay = 'withAnimation';

  if (cfg.animation.clipName == null && cfg.model.animation != null) {
    const a = cfg.model.animation;
    if (a === 'none'){ cfg.animation.clipName = null; cfg.animation.start='none'; cfg.animation.loop=false; }
    else if (a === '*' || a === ''){ cfg.animation.clipName='*'; }
    else { cfg.animation.clipName=a; }
  }
  if (!cfg.animation.start) cfg.animation.start = 'onPlace'; // Standard im AR-Kontext
  if (cfg.animation.loop == null) cfg.animation.loop = true;
  if (cfg.animation.iterations == null) cfg.animation.iterations = 9999;
}

function buildNativeLink(cfg){
  const glb  = resolveRel(cfg.model?.url||'scene.glb', cfg);
  const usdz = resolveRel(cfg.model?.usdzUrl||'', cfg);
  const ua = navigator.userAgent || '';
  const isiOSUA = /iPhone|iPad|iPod/.test(ua) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);
  if (isiOSUA && usdz) return usdz; // Quick Look
  // Android Scene Viewer Intent
  const file = encodeURIComponent(glb);
  const title = encodeURIComponent(cfg.meta?.title || 'ARea Model');
  return `intent://arvr.google.com/scene-viewer/1.0?file=${file}&mode=ar_preferred&title=${title}#Intent;scheme=https;package=com.google.android.googlequicksearchbox;end;`;
}

// ---------- THREE Setup ----------
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio||1, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 50);
const light = new THREE.HemisphereLight(0xffffff, 0x334466, 1.2); scene.add(light);
const dir   = new THREE.DirectionalLight(0xffffff, 1.8); dir.position.set(0,3,1); scene.add(dir);

addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});

// Reticle
const reticle = new THREE.Mesh(
  new THREE.RingGeometry(0.09, 0.1, 48).rotateX(-Math.PI/2),
  new THREE.MeshBasicMaterial({ color:0x88ccff, transparent:true, opacity:0.9 })
);
reticle.matrixAutoUpdate = false;
reticle.visible = false;
scene.add(reticle);

// Model + Animation
let model=null, modelRoot=null;
let mixer=null, audio=null, audioMuted=false;
let placed=false;
let baseScale=1;

const loader = new GLTFLoader();
const draco = new DRACOLoader(); draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
loader.setDRACOLoader(draco);

async function loadModel(cfg){
  const glbUrl = resolveRel(cfg.model?.url||'scene.glb', cfg);
  const gltf = await loader.loadAsync(glbUrl);
  const root = gltf.scene || gltf.scenes?.[0];

  model = new THREE.Group(); model.name='ModelRoot'; model.add(root);
  modelRoot = root;
  model.visible = false;
  scene.add(model);

  baseScale = cfg.model?.scale || 1;
  model.scale.setScalar(baseScale);

  // Animationen
  if (gltf.animations?.length){
    model.animations = gltf.animations;
    mixer = new THREE.AnimationMixer(modelRoot);
  }

  // Optional Audio
  if (cfg.audio?.url){
    const listener = new THREE.AudioListener(); camera.add(listener);
    const sound = new THREE.Audio(listener);
    const url = resolveRel(cfg.audio.url, cfg);
    try{
      const res = await fetch(url); const buff = await res.arrayBuffer();
      const ctx = listener.context; const abuf = await ctx.decodeAudioData(buff);
      sound.setBuffer(abuf); sound.setLoop(!!cfg.audio.loop); sound.setVolume(Number.isFinite(cfg.audio.volume)?cfg.audio.volume:0.85);
      audio = sound; model.add(sound);
      document.getElementById('btnMute').style.display = '';
    }catch(e){ console.warn('Audio konnte nicht geladen werden:', e); }
  }
}

function selectClip(cfg){
  if (!mixer || !model?.animations?.length) return null;
  const clips = model.animations;
  const want  = cfg.animation?.clipName;

  if (want === 'none' || want === null) return null;
  if (want && want !== '*'){
    return clips.find(c=>c.name===want) || clips[0] || null;
  }
  return clips[0] || null;
}

function playAnimation(cfg){
  if (!mixer) return;
  const clip = selectClip(cfg);
  if (!clip) return;

  mixer.stopAllAction();
  const act = mixer.clipAction(clip);
  const loopOn = cfg.animation?.loop !== false;
  if (loopOn){
    act.setLoop(THREE.LoopRepeat, cfg.animation?.iterations ?? 9999);
  }else{
    act.setLoop(THREE.LoopOnce, 0);
    act.clampWhenFinished = true;
  }
  act.reset().play();
  mixer.timeScale = 1;

  if (cfg.audio?.autoplay === 'withAnimation' && audio && audio.buffer){
    try { audio.play(); } catch(_) {}
  }
}

function pauseAnimationAndAudio(){
  if (mixer) mixer.timeScale = 0;
  if (audio?.isPlaying){ try{ audio.stop(); }catch{} }
}

// ---------- WebXR ----------
let xrSession=null, hitTestSource=null;

// Start mit stabilem Muster wie webxr.html
async function startXR(cfg){
  if (!navigator.xr) throw new Error('WebXR wird in diesem Browser nicht unterstützt.');
  let session = null;

  // 1) Bevorzugt: local-floor erzwingen (wie dein funktionierender Viewer)
  try {
    session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test','local-floor'],
      optionalFeatures: ['dom-overlay'],
      domOverlay: { root: document.body }
    });
    // XRManager auf local-floor setzen, bevor die Session gebunden wird
    try { renderer.xr.setReferenceSpaceType('local-floor'); } catch {}
    await renderer.xr.setSession(session);
  } catch {
    // 2) Fallback: nur hit-test + local (KEIN nativer Fallback hier)
    session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test'],
      optionalFeatures: ['dom-overlay'],
      domOverlay: { root: document.body }
    });
    try { renderer.xr.setReferenceSpaceType('local'); } catch {}
    await renderer.xr.setSession(session);
  }

  xrSession = session;

  // viewerSpace + Hit-Test Quelle – robust, aber ohne Abbruchmeldungen
  let viewerSpace = null;
  try { viewerSpace = await session.requestReferenceSpace('viewer'); } catch(e) {
    // Sehr selten; wenn viewerSpace fehlt, funktioniert Hit-Test nicht sinnvoll
    console.warn('viewerSpace nicht verfügbar:', e);
  }
  if (viewerSpace) {
    try { hitTestSource = await session.requestHitTestSource({ space: viewerSpace }); }
    catch(e){ console.warn('Hit-Test Source nicht verfügbar:', e); }
  }

  // Platzierung
  session.addEventListener('select', ()=>{
    if (!hitTestSource || !model) return;
    // Wir verwenden weiter unten die Reticle-Pose; falls Reticle nicht sichtbar: nichts tun
    if (!reticle.visible) return;

    const m = new THREE.Matrix4(); m.copy(reticle.matrix);
    model.matrix.copy(m);
    model.matrix.decompose(model.position, model.quaternion, model.scale);
    model.visible = true;
    placed = true;

    const start = (cfg.animation?.start || 'onPlace').toLowerCase();
    if (start === 'onplace' || start === 'onstart'){
      playAnimation(cfg);
    }
    document.getElementById('hud').style.display = '';
  });

  // Renderloop: ReferenceSpace kommt aus XRManager (local-floor/local)
  const clock = renderer.xr.getClock();
  renderer.setAnimationLoop((time, frame)=>{
    if (!frame) return;
    const dt = clock.getDelta();
    if (mixer) mixer.update(dt);

    if (hitTestSource){
      const ref = renderer.xr.getReferenceSpace();
      const hits = frame.getHitTestResults(hitTestSource);
      if (hits.length){
        const pose = hits[0].getPose(ref);
        if (pose?.transform){
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        }
      } else {
        reticle.visible = false;
      }
    }

    renderer.render(scene, camera);
  });
}

// ---------- Boot ----------
const btnEnter  = document.getElementById('enter');
const btnNative = document.getElementById('native');
const btnRepose = document.getElementById('btnRepose');
const btnPlay   = document.getElementById('btnPlay');
const btnMute   = document.getElementById('btnMute');

let CFG={};

btnRepose.onclick = ()=>{
  if (!model) return;
  pauseAnimationAndAudio();
  model.visible = false;
  placed = false;
};

btnPlay.onclick = ()=>{
  if (!mixer) return;
  const ts = mixer.timeScale ?? 1;
  if (ts === 0){
    mixer.timeScale = 1;
    if (CFG.audio?.autoplay === 'withAnimation' && audio && audio.buffer && !audio.isPlaying){
      try{ audio.play(); }catch{}
    }
  } else {
    mixer.timeScale = 0;
    if (audio?.isPlaying){ try{ audio.stop(); }catch{} }
  }
};

btnMute.onclick = ()=>{
  if (!audio) return;
  audioMuted = !audioMuted;
  audio.setVolume(audioMuted ? 0 : (Number.isFinite(CFG.audio?.volume)?CFG.audio.volume:0.85));
  btnMute.classList.toggle('danger', audioMuted);
};

(async ()=>{
  try{
    CFG = await loadConfig();
    normalizeCfg(CFG);

    await loadModel(CFG);

    // Play/Pause Button nur zeigen, wenn Start onClick oder manual ist
    const startMode = (CFG.animation?.start || 'onPlace').toLowerCase();
    btnPlay.style.display = (startMode==='onclick' || startMode==='manual') && (mixer && model?.animations?.length) ? '' : 'none';
    btnMute.style.display = audio ? '' : 'none';

    // Probe: WebXR?
    let canWebXR=false;
    try{ canWebXR = !!navigator.xr && await navigator.xr.isSessionSupported('immersive-ar'); }catch{}
    if (!canWebXR){
      // Nur falls wirklich kein WebXR verfügbar ist → native anbieten
      btnNative.style.display = 'inline-block';
      btnNative.onclick = ()=>{ location.href = buildNativeLink(CFG); };
    }

    btnEnter.onclick = async ()=>{
      try{
        if (!!navigator.xr && await navigator.xr.isSessionSupported('immersive-ar')){
          await startXR(CFG);
          btnEnter.style.display='none';
        } else {
          location.href = buildNativeLink(CFG);
        }
      }catch(e){
        // Keine harte Fehlermeldung; optional: native öffnen oder dezenten Hinweis
        console.warn('startXR Fehler:', e);
        showErr((e?.message||String(e)));
      }
    };

  }catch(e){
    showErr(e?.message||String(e));
  }
})();
</script>
</body>
</html>
