<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>ARea ‚Äì Surface (Guided)</title>
<link rel="icon" href="data:,">
<style>
  :root{ --bg:#0e1116; --panel:#111828; --panel2:#192339; --text:#e9ecf5; --muted:#9fb3d9; --border:#24314a; }
  html,body{height:100%;margin:0;background:#000;color:var(--text);font:16px/1.4 system-ui,Segoe UI,Inter,Roboto,Arial}
  #app{position:fixed;inset:0}
  canvas{display:block;width:100%;height:100%}

  /* Kamera-Preview hinter dem Welcome (best effort) */
  #camPreview{position:fixed;inset:0;object-fit:cover;z-index:0;display:none}

  /* ========= Welcome als Kachel/Card (statt Fullscreen) ========= */
  .overlay{
    position:fixed; inset:0; display:grid; place-items:center;
    padding:16px; z-index:4;
    background: color-mix(in srgb, var(--bg) 60%, transparent);
    backdrop-filter: blur(4px);
  }
  .card{
    width:min(88vw, 420px);
    border:1px solid var(--border);
    border-radius:18px;
    background:var(--panel);
    box-shadow:0 14px 40px rgba(0,0,0,.45), 0 0 0 1px rgba(255,255,255,.04);
    overflow:hidden;
    display:grid; grid-template-rows: auto 1fr;
  }
  .poster{min-height:0}
  .poster img{
    width:100%;
    aspect-ratio:16/9;       /* Kachel, nicht Vollbild */
    object-fit:cover; display:block; background:#0a0f1e;
  }
  .body{
    padding:14px 16px calc(16px + env(safe-area-inset-bottom));
  }
  .eyebrow{font-size:12px;letter-spacing:.18em;text-transform:uppercase;color:var(--muted)}
  h1{font-size:18px;margin:.35rem 0 .4rem;line-height:1.25}
  p{color:#cbd5e1;margin:.2rem 0 .8rem}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:.6rem}
  .btn{
    cursor:pointer;border:1px solid var(--border);
    background:linear-gradient(180deg,#1a2337,#162033);
    color:var(--text);padding:8px 12px;border-radius:10px;font-weight:800
  }
  @media (min-width:900px) and (min-height:540px){
    .card{ width:min(880px,92vw); grid-template-columns:320px 1fr; grid-template-rows:auto }
    .poster img{ height:100%; aspect-ratio:auto }
  }

  /* HUD */
  .hud{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;display:flex;gap:10px;
       background:rgba(14,17,22,.6);border:1px solid var(--border);border-radius:999px;padding:8px;
       backdrop-filter: blur(6px);z-index:3}
  .hud button{all:unset;cursor:pointer;padding:8px 12px;border-radius:10px}
  .toast{position:fixed;top:12px;right:12px;background:#111828;border:1px solid #24314a;color:#dbe1f1;
         padding:8px 12px;border-radius:10px;font-size:13px;box-shadow:0 8px 24px rgba(0,0,0,.25);z-index:5}

  /* Scan-Loader */
  .scan-loader{position:fixed;inset:0;display:grid;place-items:center;z-index:5;pointer-events:none;transition:opacity .25s,visibility .25s}
  .scan-loader.hidden{opacity:0;visibility:hidden}
  #wifi-loader{
    --front-color:#7dd3fc;--back-color:color-mix(in srgb,#7dd3fc 25%,transparent);--text-color:#9fb3d9;
    width:64px;height:64px;border-radius:50px;position:relative;display:flex;justify-content:center;align-items:center
  }
  #wifi-loader svg{position:absolute}
  #wifi-loader svg circle{fill:none;stroke-width:6px;stroke-linecap:round;stroke-linejoin:round;transform:rotate(-100deg);transform-origin:center}
  #wifi-loader svg circle.back{stroke:var(--back-color)}
  #wifi-loader svg circle.front{stroke:var(--front-color)}
  #wifi-loader svg.circle-outer{height:86px;width:86px}
  #wifi-loader svg.circle-outer circle{stroke-dasharray:62.75 188.25}
  #wifi-loader svg.circle-outer circle.back{animation:co 1.8s ease infinite .3s}
  #wifi-loader svg.circle-outer circle.front{animation:co 1.8s ease infinite .15s}
  #wifi-loader svg.circle-middle{height:60px;width:60px}
  #wifi-loader svg.circle-middle circle{stroke-dasharray:42.5 127.5}
  #wifi-loader svg.circle-middle circle.back{animation:cm 1.8s ease infinite .25s}
  #wifi-loader svg.circle-middle circle.front{animation:cm 1.8s ease infinite .1s}
  #wifi-loader svg.circle-inner{height:34px;width:34px}
  #wifi-loader svg.circle-inner circle{stroke-dasharray:22 66}
  #wifi-loader svg.circle-inner circle.back{animation:ci 1.8s ease infinite .2s}
  #wifi-loader svg.circle-inner circle.front{animation:ci 1.8s ease infinite .05s}
  #wifi-loader .text{position:absolute;bottom:-40px;font-weight:600;font-size:14px;letter-spacing:.2px;color:var(--text-color)}
  @keyframes co{0%{stroke-dashoffset:25}25%{stroke-dashoffset:0}65%{stroke-dashoffset:301}80%{stroke-dashoffset:276}100%{stroke-dashoffset:276}}
  @keyframes cm{0%{stroke-dashoffset:17}25%{stroke-dashoffset:0}65%{stroke-dashoffset:204}80%{stroke-dashoffset:187}100%{stroke-dashoffset:187}}
  @keyframes ci{0%{stroke-dashoffset:9}25%{stroke-dashoffset:0}65%{stroke-dashoffset:106}80%{stroke-dashoffset:97}100%{stroke-dashoffset:97}}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<video id="camPreview" autoplay muted playsinline></video>
<div id="app"></div>

<!-- Welcome -->
<div id="welcome" class="overlay">
  <div class="card">
    <div class="poster"><img id="welcomePoster" alt="Poster"></div>
    <div class="body">
      <div class="eyebrow" id="welcomeEyebrow">ARea ‚Äì Szene</div>
      <h1 id="welcomeTitle">Willkommen</h1>
      <p id="welcomeDesc">Tippe auf OK, um die Umgebung zu scannen und das Objekt zu platzieren.</p>
      <div class="row">
        <button id="welcomeStart" class="btn" onclick="window.__start && window.__start()">OK</button>
        <span class="muted" id="welcomeHint" style="color:#9fb3d9;font-size:13px">Evtl. erfordert Kamera/Audio einen Tipp</span>
      </div>
    </div>
  </div>
</div>

<!-- Scan-Loader -->
<div id="scanLoader" class="scan-loader hidden" aria-live="polite">
  <div id="wifi-loader">
    <svg class="circle-outer" viewBox="0 0 86 86">
      <circle class="back" cx="43" cy="43" r="40"></circle>
      <circle class="front" cx="43" cy="43" r="40"></circle>
    </svg>
    <svg class="circle-middle" viewBox="0 0 60 60">
      <circle class="back" cx="30" cy="30" r="27"></circle>
      <circle class="front" cx="30" cy="30" r="27"></circle>
    </svg>
    <svg class="circle-inner" viewBox="0 0 34 34">
      <circle class="back" cx="17" cy="17" r="14"></circle>
      <circle class="front" cx="17" cy="17" r="14"></circle>
    </svg>
    <div class="text">Scanne Umgebung‚Ä¶</div>
  </div>
</div>

<!-- HUD -->
<div id="hud" class="hud" style="display:none">
  <button id="btnPlay" title="Play/Pause">‚ñ∂Ô∏é/‚è∏</button>
  <button id="btnReplay" title="Neu starten">‚Üª</button>
  <button id="btnSound" title="Ton an/aus">üîä</button>
</div>

<div id="toasts" style="display:grid;gap:10px;position:fixed;top:12px;right:12px"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader }  from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

const $ = s => document.querySelector(s);
const app   = $('#app');
const toasts= $('#toasts');
const welcome = $('#welcome'),
      poster  = $('#welcomePoster'),
      wTitle  = $('#welcomeTitle'),
      wDesc   = $('#welcomeDesc'),
      wStart  = $('#welcomeStart'),
      wEyebrow= $('#welcomeEyebrow');
const hud = $('#hud'),
      btnPlay  = $('#btnPlay'),
      btnReplay= $('#btnReplay'),
      btnSound = $('#btnSound');
const camPreview = $('#camPreview');
const scanLoader = $('#scanLoader');

const toast = (m)=>{ const d=document.createElement('div'); d.className='toast'; d.textContent=m; toasts.appendChild(d); setTimeout(()=>d.remove(),2400); };
const show  = (el,on)=>{ el && (el.style.display = on ? '' : 'none'); };

const qs = new URLSearchParams(location.search);
const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/,'');
const sceneId    = (qs.get('scene') || qs.get('id') || '').trim();
const src        = (qs.get('src')   || '').trim();
const configURL  = src || (sceneId ? `${workerBase}/scenes/${encodeURIComponent(sceneId)}/scene.json` : '');
if (!configURL) toast('Keine scene.json ‚Äì ?scene=ID oder ?src=URL verwenden.');

const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance', alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.setClearColor(0x000000, 0);
renderer.setSize(innerWidth, innerHeight);
app.appendChild(renderer.domElement);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 100);
camera.position.set(2.5,1.6,3.6);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.target.set(0,1,0);

const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.9); scene.add(hemi);
const dir  = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(4,6,3); scene.add(dir);

/* ==== Audio/Anim ==== */
const listener = new THREE.AudioListener(); camera.add(listener);
const audio = new THREE.Audio(listener);
const audioLoader = new THREE.AudioLoader();
const clock = new THREE.Clock();

let mixer=null, actions=[], playing=false;
let cfg=null, gltf=null, root=null;

let baseVolume=.85, audioReady=false, allowAudio=false;
let xrSession=null, hitTestSource=null, hitTestRequested=false, placed=false;
let pendingPlacementMatrix=null;
let lastPoseMatrix=null;
let loaderShownOnce=false;
let sessionStartMs=0;

/* Try camera preview behind welcome (best effort) */
async function tryStartPreview(){
  try{
    if (!navigator.mediaDevices?.getUserMedia) return;
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ideal:'environment'}}, audio:false });
    camPreview.srcObject = stream;
    await camPreview.play();
    camPreview.style.display = '';
  }catch{}
}
tryStartPreview(); // kann auf iOS geblockt sein ‚Äì wir versuchen es nach OK erneut

function deepMerge(a,b){ for(const k in b){ if(b[k] && typeof b[k]==='object' && !Array.isArray(b[k])) a[k]=deepMerge(a[k]||{},b[k]); else a[k]=b[k]; } return a; }
const DEFAULTS = {
  ui:{ welcome:{ eyebrow:'ARea ‚Äì Szene', title:'Willkommen', desc:'Tippe auf OK, um zu starten.', cta:'OK', poster:'' }, controls:{ showPlay:true, showMute:true } },
  camera:{ fov:50, near:.01, far:100, start:[2.5,1.6,3.6], lookAt:[0,1,0] },
  model:{ url:'', scale:1, rotateY:0, realWorldMaxDim:null, realWorldHeight:null, autoFit:true, maxDim:1.2 },
  animation:{ enabled:true, clipName:'*', start:'onStart', loop:true, iterations:Infinity, clampWhenFinished:true, crossfade:.2, timeScale:1 },
  audio:{ url:'', autoplay:'withAnimation', loop:true, volume:.85 }
};
const resolveRel = (u, base)=> !u ? u : ( ()=>{ try{ return new URL(u,base).href }catch{ return u } } )();

function setLoadingOnce(on, msg){
  const textEl = scanLoader?.querySelector('.text');
  if (msg && textEl) textEl.textContent = msg;
  if (on){
    if (!loaderShownOnce){ scanLoader.classList.remove('hidden'); loaderShownOnce=true; }
  } else { scanLoader.classList.add('hidden'); }
}

function updateHUD(){
  const hasAnim = actions.length>0;
  const wantPlay = (cfg?.ui?.controls?.showPlay ?? hasAnim) && hasAnim;
  const wantMute = (cfg?.ui?.controls?.showMute ?? !!cfg?.audio?.url) && !!cfg?.audio?.url;
  btnPlay.style.display   = wantPlay ? '' : 'none';
  btnReplay.style.display = wantPlay ? '' : 'none';
  btnSound.style.display  = wantMute ? '' : 'none';
  show(hud, (wantPlay || wantMute));
}

function playAll(reset=false){
  if (!actions.length) return;
  actions.forEach(a=>{
    if (reset) a.reset();
    a.enabled = true;
    a.clampWhenFinished = !!cfg.animation.clampWhenFinished;
    a.timeScale = cfg.animation.timeScale ?? 1;
    a.fadeIn(cfg.animation.crossfade || 0).play();
    a.paused = false;
  });
  playing = true;
  maybePlayAudio();
}
function pauseAll(){
  if (!actions.length) return;
  actions.forEach(a=> a.paused = true);
  playing = false;
  if (cfg.audio?.autoplay === 'withAnimation' && audioReady && audio.isPlaying) audio.stop();
}
btnPlay.addEventListener('click', ()=>{ playing ? pauseAll() : playAll(); });
btnReplay.addEventListener('click', ()=> playAll(true));

function setMuted(on){
  if (!audioReady) return;
  audio.setVolume(on ? 0 : baseVolume);
  btnSound.textContent = on ? 'üîà' : 'üîä';
}
btnSound.addEventListener('click', ()=>{
  const isMuted = audio.getVolume && audio.getVolume()===0;
  setMuted(!isMuted);
});

function maybePlayAudio(){
  if (!audioReady || !allowAudio) return;
  const mode = (cfg?.audio?.autoplay || 'withAnimation');
  if (mode === 'auto' || (mode === 'withAnimation' && playing) || (mode === 'onPlace' && placed)){
    listener.context.resume?.();
    setMuted(false);
    if (!audio.isPlaying) audio.play();
  }
}

function loadGLTF(url){
  const loader = new GLTFLoader(); loader.setCrossOrigin('anonymous');
  const draco  = new DRACOLoader(); draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(draco);
  return loader.loadAsync(url);
}

/* === Config laden === */
(async()=>{
  try{
    const r = await fetch(configURL, { mode:'cors', cache:'no-cache' });
    const j = await r.json();
    cfg = deepMerge(structuredClone(DEFAULTS), j);

    if (cfg.model?.url) cfg.model.url = resolveRel(cfg.model.url, configURL);
    if (!cfg.audio?.url && j?.audio?.src) cfg.audio.url = resolveRel(j.audio.src, configURL);
    if (cfg.audio?.url) cfg.audio.url = resolveRel(cfg.audio.url, configURL);

    let posterUrl = cfg.ui?.welcome?.poster || j?.target?.previewUrl || j?.poster;
    posterUrl = posterUrl ? resolveRel(posterUrl, configURL)
                          : (sceneId ? `${workerBase}/scenes/${encodeURIComponent(sceneId)}/poster.jpg` : null);

    document.title = (cfg.ui?.welcome?.title || 'ARea ‚Äì Surface (Guided)');
    wEyebrow.textContent = cfg.ui?.welcome?.eyebrow ?? 'ARea ‚Äì Szene';
    wTitle.textContent   = cfg.ui?.welcome?.title   ?? 'Willkommen';
    wDesc.textContent    = cfg.ui?.welcome?.desc    ?? 'Tippe auf OK, um zu starten.';
    wStart.textContent   = (cfg.ui?.welcome?.cta || 'OK');
    if (posterUrl){ poster.src = posterUrl; } else { document.querySelector('.poster').style.display='none'; }
  }catch(e){
    toast('Config konnte nicht geladen ‚Äì Defaults genutzt.'); cfg = structuredClone(DEFAULTS);
  }

  const c = cfg.camera||{};
  camera.fov = c.fov ?? camera.fov; camera.near = c.near ?? camera.near; camera.far = c.far ?? camera.far;
  camera.updateProjectionMatrix();
  if (c.start)  camera.position.set(...c.start);
  if (c.lookAt) controls.target.set(...c.lookAt);

  baseVolume = cfg.audio?.volume ?? 0.85;

  try { gltf = await loadGLTF(cfg.model.url); }
  catch(e){ toast('GLB laden fehlgeschlagen'); console.warn(e); }

  root = gltf?.scene || new THREE.Group();
  root.traverse(o=>{ if(o.isMesh){ if(o.material?.map) o.material.map.colorSpace = THREE.SRGBColorSpace; }});
  root.rotation.y = cfg.model.rotateY||0;

  // Zielgr√∂√üe (meter)
  const box = new THREE.Box3().setFromObject(root);
  const size = new THREE.Vector3(); box.getSize(size);
  const maxDim = Math.max(size.x,size.y,size.z) || 1;
  const TARGET_MAX = 0.6;
  let targetScale = cfg.model?.scale ?? 1;
  if (cfg.model?.realWorldHeight){ targetScale *= (cfg.model.realWorldHeight / (size.y || 1)); }
  else if (cfg.model?.realWorldMaxDim){ targetScale *= (cfg.model.realWorldMaxDim / maxDim); }
  else { targetScale *= (TARGET_MAX / maxDim); }
  root.scale.setScalar(targetScale);
  root.visible = false;              // <<< unsichtbar bis zur Platzierung
  scene.add(root);

  // Animation vorbereiten
  actions = [];
  if (gltf?.animations?.length && cfg.animation.enabled){
    mixer = new THREE.AnimationMixer(root);
    const clips = gltf.animations;
    const pickAll = !cfg.animation.clipName || cfg.animation.clipName==='*';
    const chosen  = pickAll ? clips : [ THREE.AnimationClip.findByName(clips, cfg.animation.clipName) || clips[0] ];
    actions = chosen.map(c=>{
      const a = mixer.clipAction(c);
      a.setLoop(cfg.animation.loop ? THREE.LoopRepeat : THREE.LoopOnce, cfg.animation.iterations ?? Infinity);
      a.clampWhenFinished = !!cfg.animation.clampWhenFinished;
      a.timeScale = cfg.animation.timeScale ?? 1;
      return a;
    });
  }
  updateHUD();

  if (cfg.audio?.url){
    try{
      await new Promise((resolve,reject)=>
        audioLoader.load(cfg.audio.url, (buf)=>{ audio.setBuffer(buf); audio.setLoop(!!cfg.audio.loop); audio.setVolume(baseVolume); audioReady=true; resolve(); }, undefined, reject)
      );
    }catch(e){ console.warn('Audio load fail', e); }
  }
})();

/* === iOS-Erkennung & Native-Fallback === */
function detectIOS(){
  const ua = navigator.userAgent || '';
  return /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}
function makeNativeFallbackUrl(){
  const url = new URL('./index.html', location.href); // surface-ar/index.html neben guided.html
  if (sceneId) url.searchParams.set('scene', sceneId);
  if (qs.get('base')) url.searchParams.set('base', qs.get('base'));
  if (src) url.searchParams.set('src', src);
  url.searchParams.set('force','native');
  return url.toString();
}

/* === AR / Hit-Test === */
async function canStartAR(){
  try { return !!(navigator.xr && await navigator.xr.isSessionSupported('immersive-ar')); }
  catch { return false; }
}
async function startAR(){
  // iOS oder kein WebXR ‚Üí direkt auf Native (model-viewer) wechseln
  if (detectIOS() || !(await canStartAR())){
    location.href = makeNativeFallbackUrl();
    return false;
  }

  setLoadingOnce(true, 'Scanne Umgebung‚Ä¶');

  xrSession = await navigator.xr.requestSession('immersive-ar', {
    requiredFeatures:['hit-test','local-floor'],
    optionalFeatures:['dom-overlay'],
    domOverlay:{ root: document.body }
  });

  renderer.xr.enabled = true;
  renderer.xr.setReferenceSpaceType('local-floor');
  await renderer.xr.setSession(xrSession);

  sessionStartMs = performance.now();

  const controller = renderer.xr.getController(0);
  controller.addEventListener('select', ()=>{ if (!placed && lastPoseMatrix) placeModelFromMatrix(lastPoseMatrix); });
  scene.add(controller);

  xrSession.addEventListener('end', ()=>{ hitTestSource=null; hitTestRequested=false; xrSession=null; });

  return true;
}

function placeModelFromMatrix(mat4){
  if (!root){ pendingPlacementMatrix = mat4.clone(); return; }
  const pos  = new THREE.Vector3();
  const quat = new THREE.Quaternion();
  const scl  = new THREE.Vector3();
  mat4.decompose(pos, quat, scl);

  root.matrixAutoUpdate = true;
  root.position.copy(pos);

  const e = new THREE.Euler().setFromQuaternion(quat, 'YXZ');
  root.rotation.y = (cfg?.model?.rotateY || 0) + e.y;

  root.visible = true;             // <<< JETZT sichtbar
  placed = true;

  if (cfg?.animation?.start === 'onStart') playAll(true);
  maybePlayAudio();
  setLoadingOnce(false);
}

/* === OK-Button === */
window.__start = async function(){
  allowAudio = true;
  try { listener?.context?.resume?.(); } catch {}

  // falls Preview zuvor blockiert war
  tryStartPreview();

  show(welcome,false);
  const arStarted = await startAR().catch(()=>false);
  if (!arStarted){
    // Fallback Desktop: Orbit + sofort animieren
    if (cfg?.animation?.start === 'onStart') playAll(true);
    maybePlayAudio();
  }
};

/* === Render === */
renderer.setAnimationLoop((t, frame)=>{
  const dt = clock.getDelta();
  mixer?.update(dt);

  if (renderer.xr.isPresenting && frame){
    const refSpace = renderer.xr.getReferenceSpace();
    const session  = renderer.xr.getSession();

    if (!hitTestRequested){
      session.requestReferenceSpace('viewer').then((viewerSpace)=>{
        session.requestHitTestSource({ space: viewerSpace }).then(src => { hitTestSource = src; });
      });
      session.addEventListener('end', ()=>{ hitTestRequested=false; hitTestSource=null; });
      hitTestRequested = true;
    }

    if (hitTestSource){
      const hits = frame.getHitTestResults(hitTestSource);
      if (hits.length){
        const pose = hits[0].getPose(refSpace);
        lastPoseMatrix = new THREE.Matrix4().fromArray(pose.transform.matrix);

        // Autoplace direkt bei erstem stabilen Treffer
        if (!placed){ placeModelFromMatrix(lastPoseMatrix); }
      }
    }

    // >>> Hard-Fallback: nach ~2s ohne Hit ‚Üí 1.2 m vor Kamera platzieren
    if (!placed && sessionStartMs && (performance.now() - sessionStartMs) > 2000){
      const cam = renderer.xr.getCamera(camera);
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion);
      const pos = new THREE.Vector3().copy(cam.position).addScaledVector(dir, 1.2);
      const mat = new THREE.Matrix4().compose(pos, cam.quaternion, new THREE.Vector3(1,1,1));
      placeModelFromMatrix(mat);
    }

  } else {
    controls.update();
  }

  if (pendingPlacementMatrix && root){
    placeModelFromMatrix(pendingPlacementMatrix);
    pendingPlacementMatrix = null;
  }

  renderer.render(scene, camera);
});

addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
