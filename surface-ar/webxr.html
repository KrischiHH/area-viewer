<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Surface AR – WebXR Hit-Test (mit Animation)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui}
  #enter{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:12px;border:1px solid #555;background:#111;color:#fff}
  #msg{position:fixed;left:12px;bottom:12px;opacity:.9}
  #err{position:fixed;left:12px;top:12px;z-index:9;background:#b00020;color:#fff;padding:8px 10px;border-radius:8px;display:none;font:12px/1.35 monospace;max-width:min(92vw,680px);white-space:pre-wrap}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader }   from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader }  from 'three/addons/loaders/DRACOLoader.js';

let camera, scene, renderer, reticle, controller, hitTestSource=null, hitTestSourceRequested=false;
let model=null, mixer=null, clips=[];
const clock = new THREE.Clock();

const showErr = (m)=>{ const el=document.getElementById('err'); el.textContent=m; el.style.display='block'; };

/* ========= Param-Normalisierung ========= */
const qs = new URLSearchParams(location.search);
const sceneParam = (qs.get('scene') || qs.get('src') || '').trim();
const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/, '');
const overrideGlb = (qs.get('glb') || '').trim();

const isHttp      = u => /^https?:\/\//i.test(u);
const isDataOrBlob= u => /^data:|^blob:/i.test(u);
const isGlbLike   = u => /\.(?:glb|gltf)(?:[?#]|$)/i.test(u);

let SCENE_GLB = '';
let SCENE_JSON = '';

if (overrideGlb) {
  SCENE_GLB = overrideGlb;
} else if (sceneParam) {
  if (isDataOrBlob(sceneParam)) {
    SCENE_JSON = sceneParam;
  } else if (isHttp(sceneParam)) {
    if (isGlbLike(sceneParam)) SCENE_GLB = sceneParam;
    else SCENE_JSON = sceneParam;
  } else {
    const id = sceneParam.replace(/\/+$/,'');
    SCENE_GLB  = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.glb`;
    SCENE_JSON = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.json`;
  }
}

const cfg = {
  modelUrl: SCENE_GLB || 'https://modelviewer.dev/shared-assets/models/Astronaut.glb',
  position: [0,0,0],
  rotation: [0,0,0],  // Grad
  scale:[0.6,0.6,0.6],
  animation: '*'
};

const rad2deg = r => (r||0) * 180/Math.PI;
const deg2rad = d => (d||0) * Math.PI/180;

/* ---------- Szene-JSON optional laden ---------- */
async function loadScene(){
  if (SCENE_GLB) { cfg.modelUrl = SCENE_GLB; return; }
  if (!SCENE_JSON) return;

  try{
    const r = await fetch(SCENE_JSON, {cache:'no-cache', mode:'cors'});
    if(!r.ok) throw new Error('scene.json Load '+r.status+' '+r.statusText);
    const j = await r.json();

    const resolveAgainstJson = (u)=>{
      if (!u) return u;
      if (isHttp(u) || isDataOrBlob(u)) return u;
      try { return new URL(u, SCENE_JSON).href; } catch { return u; }
    };

    if (j?.model?.url)                 cfg.modelUrl = resolveAgainstJson(j.model.url);
    if (Array.isArray(j?.model?.scale))    cfg.scale    = j.model.scale;
    if (Array.isArray(j?.model?.rotation)) cfg.rotation = j.model.rotation;
    if (Array.isArray(j?.model?.rotationDeg)) cfg.rotation = j.model.rotationDeg;
    if (j?.model?.animation!=null)     cfg.animation= j.model.animation;
  }catch(e){
    console.warn(e);
    showErr('scene.json konnte nicht geladen werden:\n'+e.message);
  }
}

/* ---------- Query-Fallbacks ---------- */
function applyQueryFallback(){
  const glb = qs.get('glb'); if (glb) cfg.modelUrl = glb;

  const rx = qs.get('rx'), ry = qs.get('ry'), rz = qs.get('rz');
  if (rx!=null || ry!=null || rz!=null){
    cfg.rotation = [rad2deg(parseFloat(rx)), rad2deg(parseFloat(ry)), rad2deg(parseFloat(rz))]
      .map(v=>isFinite(v)?v:0);
  }
  const px = parseFloat(qs.get('px')), py = parseFloat(qs.get('py')), pz = parseFloat(qs.get('pz'));
  if ([px,py,pz].some(v=>!isNaN(v))) cfg.position = [px||0, py||0, pz||0];

  const sx = parseFloat(qs.get('sx')), sy = parseFloat(qs.get('sy')), sz = parseFloat(qs.get('sz'));
  if ([sx,sy,sz].some(v=>!isNaN(v))) cfg.scale = [sx||1, sy||1, sz||1];
}

/* ---------- Robuster GLB/GLTF-Loader ---------- */
async function loadGLTFFlexible(url) {
  const abs = url;

  let res;
  try {
    res = await fetch(abs, { mode: 'cors', credentials: 'omit', cache: 'no-cache' });
  } catch (e) {
    showErr('Fetch fehlgeschlagen: ' + e.message);
    throw e;
  }
  if (!res.ok) {
    showErr(`HTTP ${res.status} ${res.statusText}`);
    throw new Error(`HTTP ${res.status}`);
  }

  const ct = (res.headers.get('content-type') || '').toLowerCase();
  const looksGLB =
    /\.glb(?:[?#]|$)/i.test(abs) ||
    ct.includes('model/gltf-binary') ||
    ct.includes('application/octet-stream');

  const loader = new GLTFLoader();
  loader.setCrossOrigin('anonymous');
  const draco = new DRACOLoader();
  draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(draco);

  if (looksGLB) {
    const buf = await res.arrayBuffer();
    return new Promise((resolve, reject) => loader.parse(buf, '', resolve, reject));
  } else {
    const text = await res.text();                  // **String**, nicht Objekt!
    const base = abs.replace(/[^\/?#]*([?#].*)?$/, '');
    return new Promise((resolve, reject) => loader.parse(text, base, resolve, reject));
  }
}

/* ---------- THREE Init ---------- */
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(0,6,0); scene.add(dir);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // Reticle
  const ring = new THREE.RingGeometry(0.07, 0.08, 32).rotateX(-Math.PI/2);
  const mat = new THREE.MeshBasicMaterial({color:0x66ccff});
  reticle = new THREE.Mesh(ring, mat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  addEventListener('resize', ()=>renderer.setSize(innerWidth, innerHeight));
  document.getElementById('enter').addEventListener('click', startAR);

  try { window.opener && window.opener.postMessage({ type:'webar-ready' }, location.origin); } catch {}
}

function playClips(){
  if (!mixer || !clips.length) return;
  const a = cfg.animation;
  if (a==='none') return;
  if (a==='*') clips.forEach(c=>mixer.clipAction(c).play());
  else if (typeof a==='string'){
    const c = clips.find(c=>c.name===a) || clips[0]; mixer.clipAction(c).play();
  } else {
    const idx = Math.max(0, Math.min(clips.length-1, parseInt(a||0,10))); mixer.clipAction(clips[idx]).play();
  }
}

/* ---------- Platzieren / Laden ---------- */
async function onSelect() {
  if (!reticle.visible) return;

  if (!model) {
    try {
      const gltf = await loadGLTFFlexible(cfg.modelUrl);
      model = gltf.scene;
      const [sx,sy,sz]=cfg.scale;    model.scale.set(sx,sy,sz);
      const [rx,ry,rz]=cfg.rotation; model.rotation.set(deg2rad(rx), deg2rad(ry), deg2rad(rz));
      model.position.setFromMatrixPosition(reticle.matrix);
      scene.add(model);

      clips = gltf.animations || [];
      if (clips.length){ mixer = new THREE.AnimationMixer(model); playClips(); }
    } catch (err) {
      console.error('GLTF load failed', err);
      showErr('Fehler beim Laden des Objekts:\n' + (err?.message || err || 'Unbekannt'));
    }
  } else {
    model.position.setFromMatrixPosition(reticle.matrix);
  }
}

/* ---------- WebXR ---------- */
async function startAR(){
  if (!navigator.xr) { showErr('WebXR nicht verfügbar.'); return; }
  const isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
  if (!isARSupported) { showErr('Dein Gerät/Browser unterstützt kein WebXR-AR.'); return; }
  const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test','local-floor'] });
  renderer.xr.setReferenceSpaceType('local-floor');
  await renderer.xr.setSession(session);
  document.getElementById('enter').style.display='none';
  animate();
}

function animate() { renderer.setAnimationLoop(render); }

function render(t, frame) {
  const dt = clock.getDelta(); if (mixer) mixer.update(dt);
  if (!frame){ renderer.render(scene, camera); return; }
  const referenceSpace = renderer.xr.getReferenceSpace();
  const session = renderer.xr.getSession();

  if (!hitTestSourceRequested) {
    session.requestReferenceSpace('viewer').then((viewerSpace) => {
      session.requestHitTestSource({ space: viewerSpace }).then((source) => { hitTestSource = source; });
    });
    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
    hitTestSourceRequested = true;
  }

  if (hitTestSource) {
    const results = frame.getHitTestResults(hitTestSource);
    if (results.length) {
      const hit = results[0];
      const pose = hit.getPose(referenceSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else { reticle.visible = false; }
  }

  renderer.render(scene, camera);
}

/* ---------- Boot ---------- */
(async ()=>{
  try{ await loadScene(); }catch(e){ console.warn(e); }
  applyQueryFallback();
  init();
})();
</script>
</head>
<body>
  <div id="err"></div>
  <button id="enter">Start AR</button>
  <div id="msg">Android Chrome empfohlen · Tippe auf den Boden, um das Modell zu platzieren</div>
</body>
</html>
