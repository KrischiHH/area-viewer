<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Surface AR – WebXR Hit-Test (mit Animation)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui}
  #enter{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:12px;border:1px solid #555;background:#111;color:#fff}
  #msg{position:fixed;left:12px;bottom:12px;opacity:.9}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';

let camera, scene, renderer, reticle, controller, hitTestSource=null, hitTestSourceRequested=false;
let model=null, mixer=null, clips=[];
const clock = new THREE.Clock();

/* ========= NEU: Param-Normalisierung wie im Native-Viewer ========= */
const qs = new URLSearchParams(location.search);

// akzeptiere ?scene=… (bevorzugt) oder Fallback ?src=…
let sceneParam = (qs.get('scene') || qs.get('src') || '').trim();

// optional: Worker-Base, sonst Default
const workerBase = (qs.get('base') || 'https://area-publish.area-webar.workers.dev').replace(/\/$/, '');
// optional: direkter GLB-Override
const overrideGlb = (qs.get('glb') || '').trim();

const isHttp = u => /^https?:\/\//i.test(u);
const isDataOrBlob = u => u.startsWith('data:') || u.startsWith('blob:');
const endsWithAny = (u, exts) => exts.some(ext => u.toLowerCase().endsWith(ext));

let SCENE_GLB = '';
let SCENE_JSON = '';

if (overrideGlb) {
  SCENE_GLB = overrideGlb;
} else if (sceneParam) {
  if (isDataOrBlob(sceneParam)) {
    SCENE_JSON = sceneParam;                    // Data-URL mit JSON
  } else if (isHttp(sceneParam)) {
    if (endsWithAny(sceneParam, ['.glb','.gltf'])) SCENE_GLB = sceneParam; // direkte GLB-URL
    else SCENE_JSON = sceneParam;               // vollständige scene.json-URL
  } else {
    // nur eine ID → Worker-Pfade bauen
    const id = sceneParam.replace(/\/+$/,'');
    SCENE_GLB  = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.glb`;
    SCENE_JSON = `${workerBase}/scenes/${encodeURIComponent(id)}/scene.json`;
  }
}
/* ========= Ende Normalisierung ========= */

const cfg = {
  modelUrl: SCENE_GLB || 'https://modelviewer.dev/shared-assets/models/Astronaut.glb',
  position: [0,0,0],        // wird bei Reticle-Tap überschrieben
  rotation: [0,0,0],        // Grad!
  scale:[0.6,0.6,0.6],
  animation: '*'
};

// ---------- Utils ----------
const rad2deg = r => (r||0) * 180/Math.PI;
const deg2rad = d => (d||0) * Math.PI/180;

// ---------- Szene aus externer JSON (optional) ----------
async function loadScene(){
  // Wenn wir bereits eine GLB-URL haben → fertig
  if (SCENE_GLB) { cfg.modelUrl = SCENE_GLB; return; }
  // Falls scene.json vorhanden: laden und übernehmen
  if (!SCENE_JSON) return;
  const r = await fetch(SCENE_JSON, {cache:'no-cache'});
  if(!r.ok) throw new Error('scene.json Load '+r.status);
  const j = await r.json();

  if (j?.model?.url)         cfg.modelUrl = j.model.url;
  if (Array.isArray(j?.model?.position)) cfg.position = j.model.position;
  // akzeptiere sowohl rotationDeg (deg) als auch rotation (deg)
  if (Array.isArray(j?.model?.rotationDeg)) cfg.rotation = j.model.rotationDeg;
  else if (Array.isArray(j?.model?.rotation)) cfg.rotation = j.model.rotation;
  if (Array.isArray(j?.model?.scale))    cfg.scale    = j.model.scale;
  if (j?.model?.animation!=null)         cfg.animation= j.model.animation;
}

// -------- Fallbacks aus Query (inkl. Bugfix px) --------
function applyQueryFallback(){
  const glb = qs.get('glb');
  if (glb) cfg.modelUrl = glb;

  // Editor schickt rx/ry/rz in RAD -> hier in Grad umwandeln
  const rx = qs.get('rx'), ry = qs.get('ry'), rz = qs.get('rz');
  if (rx!=null || ry!=null || rz!=null){
    cfg.rotation = [rad2deg(parseFloat(rx)), rad2deg(parseFloat(ry)), rad2deg(parseFloat(rz))].map(v=>isFinite(v)?v:0);
  }

  // FIX: px kam vorher fälschlich aus 'pz'
  const px = parseFloat(qs.get('px')), py = parseFloat(qs.get('py')), pz = parseFloat(qs.get('pz'));
  if ([px,py,pz].some(v=>!isNaN(v))) cfg.position = [px||0, py||0, pz||0];

  const sx = parseFloat(qs.get('sx')), sy = parseFloat(qs.get('sy')), sz = parseFloat(qs.get('sz'));
  if ([sx,sy,sz].some(v=>!isNaN(v))) cfg.scale = [sx||1, sy||1, sz||1];
}

// ---------- THREE Init ----------
function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(0,6,0); scene.add(dir);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // Reticle
  const ring = new THREE.RingGeometry(0.07, 0.08, 32).rotateX(-Math.PI/2);
  const mat = new THREE.MeshBasicMaterial({color:0x66ccff});
  reticle = new THREE.Mesh(ring, mat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  addEventListener('resize', ()=>renderer.setSize(innerWidth, innerHeight));

  document.getElementById('enter').addEventListener('click', startAR);

  // --- Handshake: Editor informieren, dass Viewer bereit ist
  try { window.opener && window.opener.postMessage({ type:'webar-ready' }, location.origin); } catch {}
}

// ---------- Model-Animation ----------
function playClips(){
  if (!mixer || !clips.length) return;
  const a = cfg.animation;
  if (a==='none') return;
  if (a==='*'){
    clips.forEach(c=>mixer.clipAction(c).play());
  } else if (typeof a==='string'){
    const c = clips.find(c=>c.name===a) || clips[0]; mixer.clipAction(c).play();
  } else {
    const idx = Math.max(0, Math.min(clips.length-1, parseInt(a||0,10))); mixer.clipAction(clips[idx]).play();
  }
}

// ---------- Platzieren / Laden ----------
function onSelect() {
  if (!reticle.visible) return;

  const loader = new GLTFLoader();
  loader.setCrossOrigin('anonymous');

  if (!model) {
    loader.load(cfg.modelUrl, (gltf) => {
      model = gltf.scene;
      const [sx,sy,sz]=cfg.scale; model.scale.set(sx,sy,sz);
      const [rx,ry,rz]=cfg.rotation; model.rotation.set(deg2rad(rx), deg2rad(ry), deg2rad(rz));
      model.position.setFromMatrixPosition(reticle.matrix);
      scene.add(model);
      clips = gltf.animations||[];
      if (clips.length){ mixer = new THREE.AnimationMixer(model); playClips(); }
    }, undefined, (err)=>{ console.error('GLB load failed', err); });
  } else {
    model.position.setFromMatrixPosition(reticle.matrix);
  }
}

// ---------- WebXR ----------
async function startAR(){
  if (!navigator.xr) return alert('WebXR nicht verfügbar.');
  const isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
  if (!isARSupported) return alert('Dein Gerät/Browser unterstützt kein WebXR-AR.');
  const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test','local-floor'] });
  renderer.xr.setReferenceSpaceType('local-floor');
  await renderer.xr.setSession(session);
  document.getElementById('enter').style.display='none';
  animate();
}

function animate() { renderer.setAnimationLoop(render); }

function render(t, frame) {
  const dt = clock.getDelta(); if (mixer) mixer.update(dt);
  if (!frame){ renderer.render(scene, camera); return; }
  const referenceSpace = renderer.xr.getReferenceSpace();
  const session = renderer.xr.getSession();

  if (!hitTestSourceRequested) {
    session.requestReferenceSpace('viewer').then((viewerSpace) => {
      session.requestHitTestSource({ space: viewerSpace }).then((source) => { hitTestSource = source; });
    });
    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
    hitTestSourceRequested = true;
  }

  if (hitTestSource) {
    const results = frame.getHitTestResults(hitTestSource);
    if (results.length) {
      const hit = results[0];
      const pose = hit.getPose(referenceSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else { reticle.visible = false; }
  }

  renderer.render(scene, camera);
}

// ---------- Editor-Integration: postMessage ----------
function applyTransformFromMsg(t){
  if (!t) return;
  cfg.scale    = [t.sx ?? 1, t.sy ?? 1, t.sz ?? 1];
  cfg.rotation = [rad2deg(t.rx), rad2deg(t.ry), rad2deg(t.rz)];
  cfg.position = [t.px ?? 0, t.py ?? 0, t.pz ?? 0]; // bei Reticle-Tap nicht verwendet
  if (model){
    const [sx,sy,sz]=cfg.scale; model.scale.set(sx,sy,sz);
    const [rx,ry,rz]=cfg.rotation; model.rotation.set(deg2rad(rx), deg2rad(ry), deg2rad(rz));
  }
}

window.addEventListener('message', async (e)=>{
  if (e.origin !== location.origin) return;
  const msg = e.data || {};
  if (msg.type !== 'webar-load') return;

  try{
    const blob = new Blob([msg.glbBuffer], { type:'model/gltf-binary' });
    const url  = URL.createObjectURL(blob);
    cfg.modelUrl = url;
    applyTransformFromMsg(msg.transform || {});
    setTimeout(()=> URL.revokeObjectURL(url), 60000);
    console.log('[viewer] Modell per postMessage registriert – tippe zum Platzieren.');
  }catch(err){
    console.error('[viewer] Laden via postMessage fehlgeschlagen', err);
  }
});

// ---------- Boot ----------
(async ()=>{
  try{ await loadScene(); }catch(e){ console.warn(e); }
  applyQueryFallback();
  init();
})();
</script>
</head>
<body>
  <button id="enter">Start AR</button>
  <div id="msg">Android Chrome empfohlen · Tippe auf den Boden, um das Modell zu platzieren</div>
</body>
</html>
